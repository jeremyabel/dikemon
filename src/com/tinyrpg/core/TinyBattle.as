package com.tinyrpg.core {										import com.greensock.TweenLite;	import com.greensock.easing.Back;	import com.greensock.easing.SteppedEase;	import com.greensock.plugins.ColorMatrixFilterPlugin;	import com.greensock.plugins.EndArrayPlugin;	import com.greensock.plugins.TweenPlugin;	import com.tinyrpg.data.TinyAppSettings;	import com.tinyrpg.data.TinySpecialsList;	import com.tinyrpg.data.TinyStats;	import com.tinyrpg.display.TinyBattleBackground;	import com.tinyrpg.display.TinyBattlePartyDisplay;	import com.tinyrpg.display.TinyDamageNumbers;	import com.tinyrpg.display.TinyOneLineBox;	import com.tinyrpg.display.misc.GameOver;	import com.tinyrpg.display.misc.SlashGradient;	import com.tinyrpg.events.TinyBattleEvent;	import com.tinyrpg.events.TinyInputEvent;	import com.tinyrpg.managers.TinyAudioManager;	import com.tinyrpg.managers.TinyInputManager;	import com.tinyrpg.ui.TinyBattleMenu;	import com.tinyrpg.ui.TinyVictoryModal;	import com.tinyrpg.utils.TinyLogManager;	import com.tinyrpg.utils.TinyMath;	import flash.display.Bitmap;	import flash.display.Sprite;	import flash.events.Event;	import flash.geom.Point;	/**	 * @author jeremyabel	 */	public class TinyBattle extends Sprite 	{		public static var enemyParty 	: TinyParty;		public static var partyDisplay	: TinyBattlePartyDisplay;		public static var enemyDisplay	: TinyBattlePartyDisplay;		public static var staticCurrentItem : TinyItem;		public static var battleMenu 	 : TinyBattleMenu;		public static var finalBattles	 : Boolean = false;		public static var finalBattleSize: int = 0;				public var won 					 : Boolean;				private static const ATTACK_TO_ANIM_DELAY : int = 8; 	// Time between attacking animation and damage fx animation				private var activeCharacter 	 : TinyStatsEntity;		private var turnOrder			 : Array = [];		private var revivedTurn			 : Array = [];		private var nTurns				 : int = 0;		private var battleBackground	 : TinyBattleBackground; 		private var partyDisplay		 : TinyBattlePartyDisplay;		private var enemyDisplay		 : TinyBattlePartyDisplay;		private var currentItem			 : TinyItem;		private var canRun				 : Boolean;		private var nEnemies			 : int;		private var accumulatedGold		 : int;		private var accumulatedXP		 : int;		private var accumulatedItems	 : Array = [];		private var savedPlayerPos		 : Point;		private var savedFacing			 : String;		private var battleEndTurn		 : int;		private var impossible			 : Boolean;		public  var finalBattle			 : Boolean;		private var boss				 : Boolean;		private var forceStart			 : String;		private var battleEventName	  	 : String;		private var battleEventCondition : String;		private var battleEvent			 : TinyEventSequence;		private var npcArray 			 : Array = [];		private var npcHolder			 : Sprite;		private var slashMask			 : Bitmap;				public function TinyBattle(enemies : Array, canRun : Boolean = true, forceEndAtTurn : int = -1, impossible : Boolean = false, finalBattle : Boolean = false, boss : Boolean = false, forceStart : String = '', event : String = '', eventCondition : String = '')		{			// Greensock plugins			TweenPlugin.activate([EndArrayPlugin, ColorMatrixFilterPlugin]);						// Set parameters			this.canRun = canRun;			this.battleEndTurn = forceEndAtTurn;			this.impossible = impossible;			this.finalBattle = finalBattle;			this.boss = boss;			this.forceStart = forceStart;			this.battleEventName = event;			this.battleEventCondition = eventCondition;				// Make enemy party (and reset stats)			var enemyParty : TinyParty = new TinyParty();			for each (var partyMember : TinyStatsEntity in enemies) {				enemyParty.addMember(partyMember);			}			TinyBattle.enemyParty = enemyParty;						this.nEnemies = enemies.length;						// Save player position for later			this.savedPlayerPos = new Point();			this.savedPlayerPos.x = TinyMath.deepCopyInt(TinyPlayer.getInstance().party.getCharByID(0).graphics.x);			this.savedPlayerPos.y = TinyMath.deepCopyInt(TinyPlayer.getInstance().party.getCharByID(0).graphics.y);						// Save player facing			this.savedFacing = TinyMath.deepCopyString(TinyFriendSprite(TinyPlayer.getInstance().party.getCharByID(0).graphics).facing);						// NPC holder			this.npcHolder = new Sprite;		}		public function startBattle() : void		{			// Display battle background			this.battleBackground = new TinyBattleBackground();						// Battle menu 			TinyBattle.battleMenu = new TinyBattleMenu;			TinyBattle.battleMenu.x = int((this.battleBackground.width / 2) - (TinyBattle.battleMenu.width / 2));			TinyBattle.battleMenu.y = 170;			TinyLogManager.log('', this);			TinyLogManager.log('==================== START BATTLE MODE ====================', this);			TinyLogManager.log('', this);						TinyFieldMap.inBattle = true;						// Slash mask			this.slashMask = new Bitmap(new SlashGradient);			this.slashMask.x =			this.slashMask.y = -448;			this.addChild(this.slashMask);			TweenLite.to(this.slashMask, 15, { x:-84, y:-84, ease:SteppedEase.create(6), useFrames:true, onComplete:this.maskInComplete });						// Sound			TinyAudioManager.play(TinyAudioManager.BATTLE_START);						// Set positioning for 4-person party			if (TinyPlayer.getInstance().party.party.length > 3) 			{				TinyBattle.finalBattles = true;				TinyBattle.finalBattleSize = 15;				TinyBattle.battleMenu.y -= TinyBattle.finalBattleSize;			}		}				private function maskInComplete() : void		{			TinyLogManager.log('maskInComplete', this);						// Display player characters			this.partyDisplay = new TinyBattlePartyDisplay(TinyPlayer.getInstance().party);			this.partyDisplay.x = this.battleBackground.width - 34;			this.partyDisplay.y = 65;			TinyBattle.partyDisplay = this.partyDisplay;						// Display enemy characters			this.enemyDisplay = new TinyBattlePartyDisplay(TinyBattle.enemyParty, true);			this.enemyDisplay.x = 34;			this.enemyDisplay.y = this.partyDisplay.y;			TinyBattle.enemyDisplay = this.enemyDisplay;						// Add 'em up			this.removeChild(this.slashMask);			this.addChild(this.battleBackground);			this.addChild(TinyBattle.battleMenu);			this.addChild(this.partyDisplay);			this.addChild(this.enemyDisplay);			this.addChild(this.npcHolder);			this.addChild(this.slashMask);						// Show interface			TinyBattle.battleMenu.show();			this.partyDisplay.show();			this.enemyDisplay.show();						// Fade up			TweenLite.to(this.slashMask, 24, { alpha:0, ease:SteppedEase.create(5), useFrames:true, onComplete:this.transitionInComplete });						// Play battle music			TinyAudioManager.getInstance().setSong(TinyAudioManager.getMusicByEnemyName(TinyStatsEntity(TinyBattle.enemyParty.party[0]).name), false);		}				private function transitionInComplete() : void		{			TinyLogManager.log('transitionInComplete', this);						// Clean up						this.removeChild(this.slashMask);						// Determine turn order			if (this.forceStart.toUpperCase() == 'PLAYER') {				 // Player starts				this.turnOrder = this.turnOrder.concat(TinyPlayer.getInstance().party.aliveParty);				this.turnOrder = this.turnOrder.concat(TinyBattle.enemyParty.party);			} else if (this.forceStart.toUpperCase() == 'ENEMY') {				// Enemy starts				this.turnOrder = this.turnOrder.concat(TinyBattle.enemyParty.party);				this.turnOrder = this.turnOrder.concat(TinyPlayer.getInstance().party.aliveParty);			} else {				if (TinyMath.randomInt() > 50) {					// Player starts					this.turnOrder = this.turnOrder.concat(TinyPlayer.getInstance().party.aliveParty);					this.turnOrder = this.turnOrder.concat(TinyBattle.enemyParty.party);				} else {					// Enemy starts					this.turnOrder = this.turnOrder.concat(TinyBattle.enemyParty.party);					this.turnOrder = this.turnOrder.concat(TinyPlayer.getInstance().party.aliveParty);				}			}						// Show dead people			var i : int = 0;			for each (var player : TinyStatsEntity in TinyPlayer.getInstance().party.party) {				if (player.dead) {					player.graphics.die();				}				i++;			}						// Set battle index			var count : int = 0;			for each (var char : TinyStatsEntity in this.turnOrder) {				char.battleIndex = count;				count++;			}						// Start turn order loop			this.cueNextCharacter(0);		}				private function takeTurn(activeCharacter : TinyStatsEntity) : void		{			var party : TinyParty = TinyPlayer.getInstance().party;						// Handle enemy turn			if (activeCharacter.isEnemy) 			{				TinyLogManager.log('', this);				TinyLogManager.log('==================== ENEMY TURN: ' + activeCharacter.name + ' ====================', this);				TinyLogManager.log('', this);								// Remove control from the user				if (TinyInputManager.getInstance().hasTarget) {					TinyInputManager.getInstance().setTarget(null);					TinyBattle.battleMenu.friendList.turnCharacter = null;										TinyBattle.battleMenu.commandMenu.removeEventListener(TinyBattleEvent.ATTACK_SELECTED, onCommandSelected);					TinyBattle.battleMenu.commandMenu.removeEventListener(TinyBattleEvent.SPECIAL_SELECTED, onCommandSelected);					TinyBattle.battleMenu.commandMenu.removeEventListener(TinyBattleEvent.ITEM_SELECTED, onCommandSelected);					TinyBattle.battleMenu.commandMenu.removeEventListener(TinyBattleEvent.RUN_SELECTED, onCommandSelected);				}								// Set active turn player - enemy				TinyBattle.battleMenu.enemyList.turnEnemy = TinyStatsEntity(activeCharacter);				this.enemyDisplay.turnCharacter = activeCharacter;				this.partyDisplay.turnCharacter = null;								var attackTarget : TinyStatsEntity;								// Figure out who to target				if (party.lengthAlive == 1) {					attackTarget = party.aliveParty[0];				} else {					var character : TinyStatsEntity;					var randomIntMin :int = TinyStatsEntity(activeCharacter).lastAttack ? 1 : 2;					switch (TinyMath.randomInt(randomIntMin, 4))					{						// Last player who attacked them, if they are still alive						case 1:							attackTarget = activeCharacter.lastAttack;							if (activeCharacter.lastAttack.dead)								attackTarget = party.aliveParty[TinyMath.randomInt(0, party.lengthAlive)];							break;												// Strongest character						case 2:							var strongest : TinyStatsEntity = party.aliveParty[0];							for each (character in party.aliveParty)								if (character.stats.HP > strongest.stats.HP) 									strongest = character;							attackTarget = strongest;							break;												// Weakest character						case 3:							var weakest : TinyStatsEntity = party.aliveParty[0];							for each (character in party.aliveParty)								if (character.stats.HP < weakest.stats.HP) 									weakest = character;							attackTarget = weakest;							break;												// Random character						default:						case 4:							attackTarget = party.aliveParty[TinyMath.randomInt(0, party.lengthAlive)];							break;					}				}								// Do attack				TweenLite.delayedCall(1, this.doEnemyAttack, [ activeCharacter, attackTarget ] );			} 			// Handle player turn			else 			{				TinyLogManager.log('', this);				TinyLogManager.log('==================== FRIEND TURN: ' + activeCharacter.name + ' ====================', this);				TinyLogManager.log('', this);												// Return control to the user				TinyInputManager.getInstance().setTarget(TinyBattle.battleMenu.commandMenu);				TinyBattle.battleMenu.commandMenu.showBattleCommands();				TinyBattle.battleMenu.commandMenu.addEventListener(TinyBattleEvent.ATTACK_SELECTED, onCommandSelected);				TinyBattle.battleMenu.commandMenu.addEventListener(TinyBattleEvent.SPECIAL_SELECTED, onCommandSelected);				TinyBattle.battleMenu.commandMenu.addEventListener(TinyBattleEvent.ITEM_SELECTED, onCommandSelected);				TinyBattle.battleMenu.commandMenu.addEventListener(TinyBattleEvent.RUN_SELECTED, onCommandSelected);								// Display active character arrows correctly				TinyBattle.battleMenu.friendList.turnCharacter = activeCharacter;				this.partyDisplay.turnCharacter = activeCharacter;				TinyBattle.battleMenu.enemyList.turnEnemy = null;				this.enemyDisplay.turnCharacter = null;			}		}				private function onCommandSelected(event : TinyBattleEvent) : void 		{			TinyLogManager.log('onCommandSelect: ' + event.type, this);						switch (event.type)			{				case TinyBattleEvent.ATTACK_SELECTED:					// Pass control to the enemy selector					TinyInputManager.getInstance().setTarget(TinyBattle.battleMenu.enemyList);					TinyBattle.battleMenu.enemyList.addEventListener(TinyBattleEvent.ENEMY_SELECTED, onEnemySelected);					TinyBattle.battleMenu.enemyList.addEventListener(TinyInputEvent.CANCEL, onAttackCancel);					break;									case TinyBattleEvent.SPECIAL_SELECTED:					TinyInputManager.getInstance().setTarget(TinyBattle.battleMenu.friendList);					TinyBattle.battleMenu.friendList.addEventListener(TinyBattleEvent.ENEMY_SELECTED, onHealTargetSelected);					TinyBattle.battleMenu.friendList.addEventListener(TinyInputEvent.CANCEL, onHealCancel);					break;									case TinyBattleEvent.ITEM_SELECTED:					// Make new item selector box...					TinyBattle.battleMenu.itemList.removeEventListener(TinyBattleEvent.ITEM_USED, onItemSelected);					TinyBattle.battleMenu.itemList.removeEventListener(TinyInputEvent.CANCEL, onItemCancel);					TinyBattle.battleMenu.resetInventory();					// Show item selector box					TinyBattle.battleMenu.itemList.show();					// Pass control					TinyBattle.battleMenu.itemList.addEventListener(TinyBattleEvent.ITEM_USED, onItemSelected);					TinyBattle.battleMenu.itemList.addEventListener(TinyInputEvent.CANCEL, onItemCancel);					TinyInputManager.getInstance().setTarget(TinyBattle.battleMenu.itemList);					break;									case TinyBattleEvent.RUN_SELECTED:					if (this.impossible) {						TinyAudioManager.play(TinyAudioManager.ERROR);					} else {						// Attempt to run						this.tryRunAway();					}					break;			}		}				///////////////////////////////////////////////////////////////////////////////////////////////		// MISC INPUT INTERMEDIARIES 		///////////////////////////////////////////////////////////////////////////////////////////////				private function onAttackCancel(event : TinyInputEvent) : void 		{			TinyLogManager.log('onAttackCancel', this);						// Return control to the command menu			TinyInputManager.getInstance().setTarget(TinyBattle.battleMenu.commandMenu);			TinyBattle.battleMenu.enemyList.turnEnemy = null;						// Clean up			TinyBattle.battleMenu.enemyList.removeEventListener(TinyBattleEvent.ENEMY_SELECTED, onEnemySelected);			TinyBattle.battleMenu.enemyList.removeEventListener(TinyInputEvent.CANCEL, onAttackCancel);		}				private function onHealCancel(event : TinyInputEvent) : void		{			TinyLogManager.log('onHealCancel', this);						// Return control to the command menu			TinyInputManager.getInstance().setTarget(TinyBattle.battleMenu.commandMenu);						// Clean up			TinyBattle.battleMenu.friendList.removeEventListener(TinyBattleEvent.ENEMY_SELECTED, onHealTargetSelected);			TinyBattle.battleMenu.friendList.removeEventListener(TinyInputEvent.CANCEL, onHealCancel);			TinyBattle.battleMenu.friendList.clearSelectedItem();		}				private function onItemCancel(event : TinyInputEvent) : void 		{			TinyLogManager.log('onItemCancel', this);						// Return control to the command menu			TinyInputManager.getInstance().setTarget(TinyBattle.battleMenu.commandMenu);			TinyBattle.battleMenu.itemList.hide();						// Clean up			TinyBattle.battleMenu.itemList.removeEventListener(TinyBattleEvent.ITEM_USED, onItemSelected);			TinyBattle.battleMenu.itemList.removeEventListener(TinyInputEvent.CANCEL, onAttackCancel);			this.currentItem = null;		}				private function onItemTargetCancel(event : TinyInputEvent = null) : void 		{			TinyLogManager.log('onItemTargetCancel', this);						// Return control to the item menu			TinyBattle.battleMenu.itemList.show();			TinyBattle.battleMenu.enemyList.turnEnemy = null;			TinyInputManager.getInstance().setTarget(TinyBattle.battleMenu.itemList);						// Clean up			TinyBattle.battleMenu.enemyList.removeEventListener(TinyBattleEvent.ENEMY_SELECTED, onItemTargetSelected);			TinyBattle.battleMenu.enemyList.removeEventListener(TinyInputEvent.CANCEL, onItemTargetCancel);			TinyBattle.battleMenu.friendList.removeEventListener(TinyBattleEvent.ENEMY_SELECTED, onItemTargetSelected);			TinyBattle.battleMenu.friendList.removeEventListener(TinyInputEvent.CANCEL, onItemTargetCancel);			TinyBattle.battleMenu.enemyList.clearSelectedItem();			TinyBattle.battleMenu.friendList.clearSelectedItem();			this.currentItem = null;						// Put back event listeners			TinyBattle.battleMenu.itemList.addEventListener(TinyBattleEvent.ITEM_USED, onItemSelected);			TinyBattle.battleMenu.itemList.addEventListener(TinyInputEvent.CANCEL, onItemCancel);		}				private function onEnemySelected(event : TinyBattleEvent) : void 		{			var target : TinyStatsEntity = event.defender;			TinyLogManager.log('onEnemySelected: ' + target.name, this);			this.doPlayerAttack(this.activeCharacter, target);						// Clean up			TinyBattle.battleMenu.enemyList.removeEventListener(TinyBattleEvent.ENEMY_SELECTED, onEnemySelected);			TinyBattle.battleMenu.enemyList.removeEventListener(TinyInputEvent.CANCEL, onAttackCancel);		}		private function onItemSelected(event : TinyBattleEvent = null) : void 		{			// Save for later			if (event) {				var targetItem : TinyItem = event.item;				this.currentItem = targetItem;				TinyBattle.staticCurrentItem = targetItem;			}						TinyLogManager.log('onItemSelected: ' + this.currentItem.name, this);						// Pass control to target selector			if (this.currentItem.isBall) {				// Pass to enemy list				TinyInputManager.getInstance().setTarget(TinyBattle.battleMenu.enemyList);				TinyBattle.battleMenu.enemyList.addEventListener(TinyBattleEvent.ENEMY_SELECTED, onItemTargetSelected);				TinyBattle.battleMenu.enemyList.addEventListener(TinyInputEvent.CANCEL, onItemTargetCancel);			} else {				// Pass to friend list				TinyInputManager.getInstance().setTarget(TinyBattle.battleMenu.friendList);				TinyBattle.battleMenu.friendList.addEventListener(TinyBattleEvent.ENEMY_SELECTED, onItemTargetSelected);				TinyBattle.battleMenu.friendList.addEventListener(TinyInputEvent.CANCEL, onItemTargetCancel);			}						// Clean up			if (event) {				TinyBattle.battleMenu.itemList.hide();				TinyBattle.battleMenu.itemList.removeEventListener(TinyBattleEvent.ITEM_USED, onItemSelected);				TinyBattle.battleMenu.itemList.removeEventListener(TinyInputEvent.CANCEL, onItemCancel);			}		}				private function onItemTargetSelected(event : TinyBattleEvent) : void 		{			var target : TinyStatsEntity = event.defender;			TinyLogManager.log('onItemTargetSelected: ' + target.name, this);						// Clean up			TinyBattle.battleMenu.itemList.hide();			TinyBattle.battleMenu.friendList.removeEventListener(TinyBattleEvent.ENEMY_SELECTED, onItemTargetSelected);			TinyBattle.battleMenu.enemyList.removeEventListener(TinyBattleEvent.ENEMY_SELECTED, onItemTargetSelected);			// Hooray, we finally use the item! ...Or can we?			/*			if ((this.currentItem.revives && !target.dead) || (target.dead && !this.currentItem.revives)) {				// Play error sfx				TinyAudioManager.play(TinyAudioManager.ERROR);				// Can't revive a living player				TinyLogManager.log('CAN\'T USE THIS ITEM', this);								// Go back to the selected phase				TinyInputManager.getInstance().setTarget(null);				this.onItemSelected();			} else {				this.useItem(this.currentItem, target);			}			*/		}				private function onHealTargetSelected(event : TinyBattleEvent) : void		{			var target : TinyStatsEntity = event.defender;			TinyLogManager.log('onHealTargetSelected: ' + target.name, this);						// Clean up			TinyBattle.battleMenu.friendList.removeEventListener(TinyBattleEvent.ENEMY_SELECTED, onHealTargetSelected);						// Can't heal dead people or fully healed people			if (target.dead || target.stats.HP >= target.stats.MHP) {				// Play error sfx				TinyAudioManager.play(TinyAudioManager.ERROR);				// Go back to the selected phase				TinyInputManager.getInstance().setTarget(TinyBattle.battleMenu.friendList);				TinyBattle.battleMenu.friendList.addEventListener(TinyBattleEvent.ENEMY_SELECTED, onHealTargetSelected);				TinyBattle.battleMenu.friendList.addEventListener(TinyInputEvent.CANCEL, onHealCancel);			} else {				this.healTarget(target);			}					}		///////////////////////////////////////////////////////////////////////////////////////////////		// BATTLE COMMAND FUNCTIONS		///////////////////////////////////////////////////////////////////////////////////////////////				private function doPlayerAttack(attacker : TinyStatsEntity, defender : TinyStatsEntity) : void		{			TinyLogManager.log('PLAYER ATTACK: ' + attacker.name + ' vs ' + defender.name, this);						// Figure number of hits			var nHits : int = Math.ceil(attacker.stats.HIT / 32) + 1;			var damage : int = 0;						// Damage = sum of all non-evaded hits			for (var i : int = 0; i < nHits; i++)			{				// Check if evaded				var chanceToHit : int = TinyConfig.BASE_HIT_CHANCE + attacker.stats.HIT - defender.stats.E_EVD;				if (TinyMath.randomInt(0, 200) * 0.75 < chanceToHit)  					damage += 1 + (TinyMath.randomInt(attacker.stats.baseDamage, attacker.stats.baseDamage * 2) - defender.stats.DEF);			}						if (this.impossible) 				damage = 0;						this.resolveTurn(true, attacker, defender, damage);		}				private function doEnemyAttack(attacker : TinyStatsEntity, defender : TinyStatsEntity) : void		{			TinyLogManager.log('ENEMY ATTACK: ' + attacker.name + ' vs ' + defender.name, this);						var damage : int = 0;						// Check to see if we use the special			if (attacker.special) 			{				if (TinyMath.randomInt() < attacker.specChance + 1) 				{					TinyLogManager.log('DOING SPECIAL', this);										// Figure out the effect					switch (attacker.special.type) 					{						// Drop HP to 1						case TinySpecialsList.TO_ONE:							damage = defender.stats.HP - 1;							break;						case 'ATTACK':							// Do damage the normal way							for (var i : int = 0; i < attacker.stats.E_HITS; i++)							{								// Check if evaded								var chanceToHit : int = TinyConfig.BASE_HIT_CHANCE + attacker.stats.E_ACC - defender.stats.baseEvade;								var randInt : int = TinyMath.randomInt(0, 200);								if (randInt * 0.75 < chanceToHit)  									damage += Math.max(TinyMath.randomInt(attacker.stats.E_ATK, attacker.stats.E_ATK * 2) - defender.stats.DEF, 1);							}					}										this.resolveTurn(false, attacker, defender, damage, false, false, false, true);					return;					}			}						// Damage = sum of all non-evaded hits			for (i = 0; i < attacker.stats.E_HITS; i++)			{				// Check if evaded				chanceToHit = TinyConfig.BASE_HIT_CHANCE + attacker.stats.E_ACC - defender.stats.baseEvade;				randInt = TinyMath.randomInt(0, 200);				if (randInt < chanceToHit)  					damage += Math.max(TinyMath.randomInt(attacker.stats.E_ATK, attacker.stats.E_ATK * 2) - defender.stats.DEF, 1);			}						// Resolve the turn			this.resolveTurn(false, attacker, defender, damage);		}				private function useItem(item : TinyItem, target : TinyStatsEntity) : void		{			TinyLogManager.log('USE ITEM: ' + item.name + ' on ' + target.name, this);						// Remove item from inventory			TinyPlayer.getInstance().inventory.removeItem(item);						// Remove item from inventory display			TinyBattle.battleMenu.itemList.removeItem(item);						// Resolve the turn			//this.resolveTurn(true, this.activeCharacter, target, item.effect, true, item.useOnEnemies, item.revives);		}				private function healTarget(target : TinyStatsEntity) : void		{			TinyLogManager.log('HEAL TARGET: ' + target.name, this);						// Heal command heals a litte less than half of target's lost HP			var deltaHP : int = target.stats.MHP - target.stats.HP;			var damage  : int = int(deltaHP / 2.25);						// Resolve the turn			this.resolveTurn(true, this.activeCharacter, target, damage, true, false, false, false, true);		}				public function resolveTurn(playerTurn : Boolean, attacker : TinyStatsEntity, defender : TinyStatsEntity, damage : int, useItem : Boolean = false, itemTargetEnemy : Boolean = false, itemRevives : Boolean = false, doingSpecial : Boolean = false, healCommand : Boolean = false) : void		{			TinyLogManager.log('resolveTurn', this);						// Really, take away control...			TinyInputManager.getInstance().setTarget(null);						// Differences between enemy and player			var attackerParty : TinyBattlePartyDisplay = (playerTurn) ? this.partyDisplay : this.enemyDisplay;			var defenderParty : TinyBattlePartyDisplay = (playerTurn) ? this.enemyDisplay : this.partyDisplay; 						// Defender party is player's party if using an item that doesn't target an enemy			if (useItem && !itemTargetEnemy)				defenderParty = this.partyDisplay;						// Every hit missed. Show the miss text			if (damage <= 0) 			{				// Show miss text				TinyLogManager.log('ATTACK: MISSED', this);				damage = 0;			} 			else 			{				// Fix damage for reviving				if (this.currentItem) {					if (useItem && this.currentItem.revive && !healCommand) {						// Damage is a percentage of target's max hp and the item effect property						damage = int(defender.stats.MHP * (this.currentItem.effectAmount * 0.01));					}				}										// Deal damage / healing				TinyLogManager.log('ATTACK: -' + damage, this);				if ((playerTurn && itemTargetEnemy && useItem && !healCommand) || (playerTurn && !useItem && !healCommand))					defender.stats.HP -= damage;				else if ((playerTurn && useItem && !itemTargetEnemy && !healCommand) || (playerTurn && healCommand)) 					defender.stats.HP += damage;				else 					defender.stats.HP -= damage;			}						// Play attacker animation			var delay : Number = 0;			if (!useItem) {				try { 					delay = ITinySprite(attackerParty.findCharByID(attacker.idNumber)).attack();				} catch (error : Error) {					delay = attacker.graphics.attack();				}			} else {				try {					// Play sound					TinyAudioManager.play(TinyAudioManager.USE_ITEM);					delay = TinyFriendSprite(attackerParty.findCharByID(attacker.idNumber)).useItem();				} catch (error : Error) {					TinyAudioManager.play(TinyAudioManager.USE_ITEM);					delay = TinyFriendSprite(attacker.graphics).useItem();				}			}						// Play defender animations and sounds			delay += ATTACK_TO_ANIM_DELAY;			if (playerTurn && useItem && !itemTargetEnemy && itemRevives) {				// Play revive				TweenLite.delayedCall(delay, TinyAudioManager.play, [TinyAudioManager.HEAL_A], true);				TweenLite.delayedCall(delay, TinyFriendSprite(defenderParty.findCharByID(defender.idNumber)).victory, null, true);				// Insert back into turn order				this.revivedTurn.push(defender);			} else if ((playerTurn && useItem && !itemTargetEnemy) || (playerTurn && healCommand)) {				// Play healing				TweenLite.delayedCall(delay, TinyAudioManager.play, [TinyAudioManager.HEAL_A], true);				TweenLite.delayedCall(delay, TinyFriendSprite(defenderParty.findCharByID(defender.idNumber)).victory, null, true);			} else {				// Play hit only if we're doing damage				if (damage > 0) {					TweenLite.delayedCall(delay, ITinySprite(defenderParty.findCharByID(defender.idNumber)).hit, [attacker.attackType], true);				// Play a miss				} else if (!this.impossible) {					TweenLite.delayedCall(delay, ITinySprite(defenderParty.findCharByID(defender.idNumber)).miss, null, true);				} else if (this.impossible) {					TweenLite.delayedCall(delay, TinyAudioManager.play, [TinyAudioManager.IMPOSSIBLE], true);				}			}						// Show damage number			delay += ITinySprite(defenderParty.findCharByID(defender.idNumber)).damageTime + 9;			TweenLite.delayedCall(delay, ITinySprite(defenderParty.findCharByID(defender.idNumber)).damageNumbers.show, [damage, (useItem && !itemTargetEnemy), this.impossible], true);						// Update stats for player			if (!playerTurn || playerTurn && useItem && !itemTargetEnemy) {				TweenLite.delayedCall(delay, TinyBattle.battleMenu.update, null, true);			}						// Is the enemy dead?			if ((playerTurn && !useItem) || (playerTurn && itemTargetEnemy)) 			{				// Remove defender from the list and character display				if (defender.stats.HP <= 0) {					delay += TinyDamageNumbers.numberTime;					TweenLite.delayedCall(delay, TinyBattle.battleMenu.enemyList.removeEnemy, [defender], true);					TweenLite.delayedCall(delay, defenderParty.killCharacter, [defender, this.boss], true);					this.turnOrder.splice(this.turnOrder.indexOf(defender), 1);					this.nEnemies--;					if (this.boss) {						delay += 100;					} else {						delay += 15;					}											// Stop audio for the end of the final battle					if (this.finalBattle) {						TinyAudioManager.getInstance().stopMusic();					}										// Add gold, xp					this.accumulatedGold += defender.stats.E_GP;					this.accumulatedXP += defender.stats.E_XP;										// Drop item?					if (defender.stats.E_ITEM) {						TinyLogManager.log('Enemy Defeated! Gain ' + defender.stats.E_GP + ' gold, ' + defender.stats.E_XP + ' xp, ' + defender.stats.E_ITEM.name, this);						this.accumulatedItems.push(defender.stats.E_ITEM);					} else {						TinyLogManager.log('Enemy Defeated! Gain ' + defender.stats.E_GP + ' gold, ' + defender.stats.E_XP + ' xp', this);					}				}				// Otherwise, proceed 				else {					delay += TinyDamageNumbers.numberTime;				}								// Are all the enemies dead? Show victory thing, otherwise goto next turn				if (this.nEnemies <= 0) {					if (!this.finalBattle) { 						TweenLite.delayedCall(delay, this.doVictory, null, true);					} else {						TweenLite.delayedCall(delay, this.onFinalEnd, null, true);					}				} else {					// Cue up next character					TweenLite.delayedCall(delay, this.cueNextCharacter, [0], true);				}			} 			// Player just healed friend			else if ((playerTurn && useItem && !itemTargetEnemy && !healCommand) || (playerTurn && healCommand)) 			{				delay += TinyDamageNumbers.numberTime;				// Cue up next character				TweenLite.delayedCall(delay, this.cueNextCharacter, [0], true);			} 			// Is the player dead?			else 			{				if (defender.stats.HP <= 0)	{					// Don't remove from list, just kill					delay += 15;					TweenLite.delayedCall(delay, defenderParty.killCharacter, [defender], true);										// Remove from turn order					this.turnOrder.splice(this.turnOrder.indexOf(defender), 1);										delay += 15;				} else {					delay += TinyDamageNumbers.numberTime;				}								// Are all the players dead? Show game over thing, otherwise goto next turn				if (TinyPlayer.getInstance().party.lengthAlive <= 0 && defender.stats.HP <= 0) {					TweenLite.delayedCall(delay, this.doGameOver, null, true);				} else {					// Cue up next character					TweenLite.delayedCall(delay, this.cueNextCharacter, [0], true);				}			}		}				private function tryRunAway() : void		{			TinyLogManager.log('tryRunAway', this);						TinyInputManager.getInstance().setTarget(null);						var player : TinyPlayer = TinyPlayer.getInstance();			var success : Boolean = false;						// Play walk cycyles fast			for each (var character : TinyStatsEntity in TinyPlayer.getInstance().party.aliveParty) 			{				var sprite : TinyFriendSprite = TinyFriendSprite(character.graphics);				sprite.runFromBattle();			}						// Check if we're allowed to run at all			if (this.canRun)			{				// Try to run				switch(player.party.lengthAlive) 				{					case 1:						// 16.8% failure rate						success = TinyMath.randomInt(1, 6) > 1;						break;					case 2:						// 5.56% failure rate						success = (TinyMath.randomInt(1, 6) + TinyMath.randomInt(1, 6)) >= 3;						break;					case 3:						// 9.26% failure rate						success = (TinyMath.randomInt(1, 6) + TinyMath.randomInt(1, 6) + TinyMath.randomInt(1, 6)) >= 6;						break;				}								TinyLogManager.log('tryRunAway: ' + success, this);			}						if (success) {				TweenLite.delayedCall(24, this.doRunAway, null, true);			} else {				// Notify of failure				TweenLite.delayedCall(60, this.allIdle, null, true);								// Skip to next enemy turn				while(!this.activeCharacter.isEnemy) {					this.activeCharacter = this.turnOrder.shift();					this.turnOrder.push(this.activeCharacter);					TinyBattle.battleMenu.commandMenu.clearSelectedItem();				}								TweenLite.delayedCall(75, this.takeTurn, [this.activeCharacter], true);			}		}				private function allIdle() : void		{			TinyLogManager.log('allIdle', this);						// Return to idling			for each (var character : TinyStatsEntity in TinyPlayer.getInstance().party.aliveParty) 			{				var sprite : TinyFriendSprite = TinyFriendSprite(character.graphics);				sprite.idleDirection('LEFT');				sprite.idleBattle();			} 		}				private function doRunAway() : void		{			TinyLogManager.log('doRunAway', this);			this.won = false;						TinyInputManager.getInstance().setTarget(null);						// Cue end of battle stuff			TweenLite.delayedCall(24, this.onBattleComplete, null, true);		}				private function onFinalEnd() : void		{			TinyLogManager.log('onFinalEnd', this);						var fadeToWhite : Sprite = new Sprite;			fadeToWhite.graphics.beginFill(0xFFFFFF);			fadeToWhite.graphics.drawRect(0, 0, 320, 240);			fadeToWhite.graphics.endFill();			fadeToWhite.alpha = 0;			this.addChild(fadeToWhite);						// Fade to white slowly			TweenLite.to(fadeToWhite, 60, { delay:30, alpha:1, ease:SteppedEase.create(8), useFrames:true });			TweenLite.delayedCall(170, this.onFinalEndFadeOut, null, true);						TinyAudioManager.getInstance().stopMusic();		}				private function onFinalEndFadeOut() : void		{			TinyLogManager.log('onFinalEndFadeOut', this);						// Clean up			this.removeChild(this.enemyDisplay);			this.removeChild(this.partyDisplay);			this.removeChild(this.battleBackground);			this.removeChild(TinyBattle.battleMenu);			this.removeChild(this.npcHolder);			this.enemyDisplay = null;			this.battleBackground = null;			TinyBattle.battleMenu = null;						TinyFieldMap.inBattle = false;						this.dispatchEvent(new Event(Event.COMPLETE));		}				private function doVictory() : void		{			TinyInputManager.getInstance().setTarget(null);			// Deselect everything			this.enemyDisplay.turnCharacter = null;			this.partyDisplay.turnCharacter = null;						TinyLogManager.log('doVictory', this);			this.won = true;			var levelUps : Array = [];						// Play little tune			TinyAudioManager.getInstance().stopMusic();			TinyAudioManager.getInstance().playMusic(TinyAudioManager.getInstance().VICTORY);						// Victory dance and xp distribution 			for each (var character : TinyStatsEntity in TinyPlayer.getInstance().party.aliveParty) 			{				// Dance!				var sprite : TinyFriendSprite = TinyFriendSprite(character.graphics);				sprite.victory();								var levelUp : Boolean;				if (this.accumulatedXP <= 0) {					// XP needed for next level									var nextXP : int = TinyStats.XP_TABLE[character.stats.LVL];					var prevXP : int = TinyStats.XP_TABLE[character.stats.LVL - 1];					var totalXPNeeded : int = nextXP - prevXP;										// XP Distribution - Add 1/2 or 1/3 needed to get to next level					levelUp = character.stats.addXP(int(totalXPNeeded / (character.stats.LVL % 2 == 0 ? 2 : 3)));					this.accumulatedXP = int(totalXPNeeded / (character.stats.LVL % 2 == 0 ? 2 : 3));				} else {					levelUp = character.stats.addXP(this.accumulatedXP);				}								if (levelUp) {					levelUps.push(character.name);				}			}						// Gold!			TinyPlayer.getInstance().inventory.gold += this.accumulatedGold;						// Show victory modal			var victoryModal : TinyVictoryModal = new TinyVictoryModal(this.accumulatedXP, this.accumulatedGold, levelUps, this.accumulatedItems);			TinyInputManager.getInstance().setTarget(victoryModal);			victoryModal.x = TinyBattle.battleMenu.x;			victoryModal.y = 10;			victoryModal.addEventListener(Event.COMPLETE, onBattleComplete);			victoryModal.show();			this.addChild(victoryModal);		}				private function doGameOver() : void		{			TinyLogManager.log('doGameOver', this);						// Deselect everything			this.enemyDisplay.turnCharacter = null;			this.partyDisplay.turnCharacter = null;						// Fade to black and white			TweenLite.to(this, 50, { colorMatrixFilter:{colorize:0xffffff}, ease:SteppedEase.create(5), useFrames:true });						// Bring in slashy pixel gradient			var pixelGradient : Bitmap = new Bitmap(new SlashGradient);			pixelGradient.x =			pixelGradient.y = -448;			this.addChild(pixelGradient);			TweenLite.to(pixelGradient, 10, { delay:65, x:-84, y:-84, useFrames:true, onComplete:this.showGameOverScreen });		}				private function showGameOverScreen() : void		{			TinyLogManager.log('showGameOverScreen', this);						// Show game over screen			var gameOverScreen : Bitmap = new Bitmap(new GameOver);			gameOverScreen.alpha = 0;			TweenLite.to(gameOverScreen, 24, { alpha:1, useFrames:true, ease:SteppedEase.create(4) });						// Show menu			//var gameOverMenu : TinyGameOverMenu = new TinyGameOverMenu;			//gameOverMenu.x = 128;			//gameOverMenu.y = 140;			//gameOverMenu.alpha = 0;			//TweenLite.to(gameOverMenu, 18, { delay:15, alpha:1, useFrames:true, ease:SteppedEase.create(4), onComplete:TinyInputManager.getInstance().setTarget, onCompleteParams:[gameOverMenu] });						// Add 'em up			this.addChild(gameOverScreen);			//this.addChild(gameOverMenu);						// Events			//gameOverMenu.addEventListener(TinyGameEvent.LOAD_GAME, onContinueSelected);			//gameOverMenu.addEventListener(TinyGameEvent.QUIT_GAME, onQuitSelected);		}				/*		private function onContinueSelected(event : TinyGameEvent) : void 		{			TinyLogManager.log('onContinueSelected', this);		}		private function onQuitSelected(event : TinyGameEvent) : void 		{			TinyLogManager.log('onQuitSelected', this);		}		 */				private function onBattleComplete(event : Event = null) : void		{			TinyLogManager.log('onBattleComplete', this);						// Clean up and fade to black, badly. 			var bigBlackSprite : Sprite = new Sprite;			bigBlackSprite.graphics.beginFill(0);			bigBlackSprite.graphics.drawRect(0, 0, this.battleBackground.width, this.battleBackground.height);			bigBlackSprite.graphics.endFill();			bigBlackSprite.alpha = 0;						this.addChild(bigBlackSprite);						TinyFieldMap.inBattle = true;						// Tween in. SteppedEase gives us a nice SNES-era lo-fi fade effect.			TweenLite.to(bigBlackSprite, 15, { alpha:1, ease:SteppedEase.create(5), useFrames:true, onComplete:this.onBattleFadeOut });		}				private function onBattleFadeOut() : void		{			TinyLogManager.log('onBattleFadeOut', this);			// Return player sprite to original position			var playerChar : TinyFriendSprite = TinyFriendSprite(TinyPlayer.getInstance().party.getCharByID(0).graphics);			playerChar.x = this.savedPlayerPos.x; 			playerChar.y = this.savedPlayerPos.y;			playerChar.facing = this.savedFacing;			playerChar.moveChar();			playerChar.idleWalk();			TinyFieldMap.getInstance().restorePlayerSprite();						// Clean up			this.removeChild(this.enemyDisplay);			this.removeChild(this.partyDisplay);			this.removeChild(this.battleBackground);			this.removeChild(TinyBattle.battleMenu);			this.removeChild(this.npcHolder);			this.enemyDisplay = null;			this.battleBackground = null;			TinyBattle.battleMenu = null;						TinyFieldMap.inBattle = false;						TweenLite.delayedCall(6, this.dispatchEvent, [new Event(Event.COMPLETE)], true);		}				private function cueNextCharacter(delay : Number = 1) : void		{			// Insert revived characters back into the turn order			if (this.activeCharacter && this.activeCharacter.battleIndex == 0) {				for each (var char : TinyStatsEntity in this.revivedTurn) {					this.turnOrder.splice(char.battleIndex - 1, 0, char);				}				// Clear the array				this.revivedTurn = [];			}						// Cycle to the next person in the turn order			this.activeCharacter = this.turnOrder.shift();			this.turnOrder.push(this.activeCharacter);			TinyBattle.battleMenu.commandMenu.clearSelectedItem();						// Increment turn counter			if (this.activeCharacter.battleIndex == 0) {				this.nTurns++;			}						// End the battle if necessary, or start the in-battle event			if (this.battleEndTurn > 0 && this.nTurns >= this.battleEndTurn + 1) 			{				if (this.battleEventCondition == 'ON_FORCE_END' && this.battleEventName != '') {					TinyLogManager.log('starting in-battle event: ' + this.battleEventName, this);					this.battleEvent = TinyEventSequence.newFromEventName(this.battleEventName);					this.battleEvent.currentBattle = this;					this.battleEvent.addEventListener(Event.COMPLETE, onBattleEventComplete);					this.battleEvent.startSequence();					this.addChild(this.battleEvent);					return;				} else {					TweenLite.delayedCall(10, this.onBattleComplete, null, true);					return;				}			}						TinyLogManager.log('cueNextCharacter: ' + this.activeCharacter.name, this);						TweenLite.delayedCall(delay, this.takeTurn, [this.activeCharacter]);		}				public function addNPCSpriteAt(npcSprite : TinyFriendSprite, x : int, y : int, facing : String = 'DOWN') : void		{			TinyLogManager.log('addNPCSpriteAt', this);						// Make new sprite			var newSprite : TinyFriendSprite = npcSprite;			newSprite.x = x;			newSprite.y = y;			newSprite.facing =			newSprite.defaultFacing = facing;			newSprite.idleWalk();						// Add 'em up			this.npcHolder.addChild(newSprite);			this.npcArray.push(newSprite);		}				public function getNPCByName(targetName : String) : TinyFriendSprite		{			TinyLogManager.log('getNPCByName: ' + targetName, this);						// Find function			var findFunction : Function = function(item : *, index : int, array : Array) : Boolean				{ index; array; return (TinyFriendSprite(item).charName.toUpperCase() == targetName.toUpperCase()); };						// Search for character			return this.npcArray.filter(findFunction)[0];		}				private function onBattleEventComplete(event : Event) : void 		{			TinyLogManager.log('onBattleEventComplete', this);						// End the battle			TweenLite.delayedCall(10, this.onBattleComplete, null, true);			return;		}	}}