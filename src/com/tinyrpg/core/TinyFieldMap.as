package com.tinyrpg.core {	import com.greensock.TweenLite;	import com.coreyoneil.collision.CollisionGroup;		import com.tinyrpg.core.TinyMon;	import com.tinyrpg.data.TinyCollisionData;	import com.tinyrpg.data.TinyWildEncounterData;	import com.tinyrpg.data.TinyFieldMapObject;	import com.tinyrpg.data.TinyFieldMapObjectNPC;	import com.tinyrpg.data.TinyFieldMapObjectSprite;	import com.tinyrpg.data.TinyFieldMapObjectTrigger;	import com.tinyrpg.data.TinyFieldMapObjectWarp;	import com.tinyrpg.display.TinyMapMovieClip;	import com.tinyrpg.events.TinyFieldMapEvent;	import com.tinyrpg.lookup.TinyMapLookup;	import com.tinyrpg.managers.TinyGameManager;	import com.tinyrpg.managers.TinyMapManager;	import com.tinyrpg.utils.TinyLogManager;	import com.tinyrpg.utils.TinyMath;	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.DisplayObject;	import flash.display.MovieClip;	import flash.display.Sprite;	import flash.events.Event;	/**	 * Class which manages a single overworld map and acts as a wrapper around {@link TinyMapMovieClip}.	 * Contains functions for handling player collisions, NPCs, map events, and mon encounters.	 * 	 * @see TinyMapMovieClip	 */	public class TinyFieldMap extends Sprite 	{		public static const COLLISION_TYPE_WALLS	: String = 'WALLS';		public static const COLLISION_TYPE_OBJECTS	: String = 'OBJECTS';		public static const COLLISION_TYPE_GRASS 	: String = 'GRASS';		public static const COLLISION_TYPE_JUMPS	: String = 'JUMPS';		public static const COLLISION_TYPE_DISABLE	: String = 'DISABLE'; 		public static const COLLISION_TYPE_TRAINER	: String = 'TRAINER';				public var mapName						: String;		public var mapUserObjects				: Sprite;		public var startingEventName			: String;		public var encounterRate				: int;		public var encounterData				: TinyWildEncounterData;		public var eventXML 					: XML;		public var globalEventXML				: XML;		private var mapMovieClip				: TinyMapMovieClip;		private var currentEventSequence		: TinyEventSequence;		private var mapObjects					: MovieClip;		private var mapBase						: MovieClip;		private var mapHit						: MovieClip;		private var mapMiscCollisionContainer 	: Sprite;		private var collisionWalls 				: CollisionGroup;		private var collisionGrass				: CollisionGroup;		private var collisionJumps				: CollisionGroup;				private var collisionObjects			: CollisionGroup;		private var collisionDisable			: CollisionGroup;		private var npcReadyCount				: uint = 0;		private var spriteReadyCount			: uint = 0;		private var npcArray					: Array = [];		private var spriteArray					: Array = [];		/**		 * Returns the name of the map to send the player to after a game over. This is typically		 * set to the nearest Dikécenter.		 * 		 * @return	the name of the map to send the player to after a game over		 */		public function get gameoverMapName() : String { return this.mapMovieClip.gameoverMapName; }						/**		 * Returns true if the map is currently running an event.		 * 		 * @return	true of the map is currently running an event		 */		public function get isRunningEvent() : Boolean { return this.currentEventSequence ? true : false; }		/**		 * Constructor which creates a map with a given name. The map name must match a string 		 * specified in {@link TinyMapLookup}. 		 */		public function TinyFieldMap( mapName : String ) : void		{			this.npcReadyCount = 0;			this.mapName = mapName;						// Find the map's encounter data with the given map name			this.encounterRate = TinyMapLookup.getEncounterRateForName( this.mapName );			this.encounterData = TinyMapLookup.getEncounterDataForName( this.mapName );						// Find the map's MovieClip with the given map name			this.mapMovieClip = TinyMapLookup.getMapFromName( this.mapName );			this.mapBase = this.mapMovieClip.map;			this.mapHit = this.mapMovieClip.hit;			this.mapHit.visible = false;						// Draw map border boundaries on the map collision layer			this.mapHit.graphics.lineStyle( 16, 0xFF00FF );			this.mapHit.graphics.drawRect( -8, -8, this.mapBase.width + 16, this.mapBase.height + 16 );			this.mapHit.graphics.endFill();						this.mapObjects = this.mapMovieClip.objects;			this.mapUserObjects = new Sprite();			this.mapMiscCollisionContainer = new Sprite();			this.mapMiscCollisionContainer.visible = false;						// Create collision groups			this.collisionWalls = new CollisionGroup( this.mapHit );			this.collisionGrass = new CollisionGroup();			this.collisionJumps = new CollisionGroup();			this.collisionObjects = new CollisionGroup();			this.collisionDisable = new CollisionGroup();						// Process all entities in the map, such as NPCs and interactive sprites (signs, for example) 			for ( var i : uint = 0; i < this.mapObjects.numChildren; i++ )			{				var mapObject : TinyFieldMapObject = ( this.mapObjects.getChildAt( i ) as TinyFieldMapObject );								// Deal with different kinds of map objects. 				if ( mapObject is TinyFieldMapObjectNPC )				{					// Wait for NPC data to be ready before adding them to the NPC array and collision groups					// If this is done too early, incorrect NPC names will be stored in the array and the 					// getNPCObjectByName() function will fail. 					mapObject.addEventListener( TinyFieldMapEvent.DATA_READY, this.onNPCDataReady );					this.npcReadyCount++;				}				else if ( mapObject is TinyFieldMapObjectSprite )				{					// Previous comment applies here as well					mapObject.addEventListener( TinyFieldMapEvent.DATA_READY, this.onSpriteDataReady );					this.spriteReadyCount++;				}				else 				{					// Add each map object to the objects collision group					this.addToCollisionGroup( mapObject.hitbox, COLLISION_TYPE_OBJECTS );				}			}						// Add optional map layers to their cooresponding collision groups if they exist			if ( this.mapMovieClip.hasGrass ) { this.mapMiscCollisionContainer.addChild( this.mapMovieClip.grass ); this.addToCollisionGroup( this.mapMovieClip.grass, COLLISION_TYPE_GRASS ); }			if ( this.mapMovieClip.hasJumpU ) { this.mapMiscCollisionContainer.addChild( this.mapMovieClip.jumpU ); this.addToCollisionGroup( this.mapMovieClip.jumpU, COLLISION_TYPE_JUMPS ); }			if ( this.mapMovieClip.hasJumpD ) { this.mapMiscCollisionContainer.addChild( this.mapMovieClip.jumpD ); this.addToCollisionGroup( this.mapMovieClip.jumpD, COLLISION_TYPE_JUMPS ); }			if ( this.mapMovieClip.hasJumpL ) { this.mapMiscCollisionContainer.addChild( this.mapMovieClip.jumpL ); this.addToCollisionGroup( this.mapMovieClip.jumpL, COLLISION_TYPE_JUMPS ); }			if ( this.mapMovieClip.hasJumpR ) { this.mapMiscCollisionContainer.addChild( this.mapMovieClip.jumpR ); this.addToCollisionGroup( this.mapMovieClip.jumpR, COLLISION_TYPE_JUMPS ); }			if ( this.mapMovieClip.hasDisableU ) { this.mapMiscCollisionContainer.addChild( this.mapMovieClip.disableU ); this.addToCollisionGroup( this.mapMovieClip.disableU, COLLISION_TYPE_DISABLE ); }						// Get event sequence XML data			this.eventXML = TinyMapLookup.getMapEventXMLFromName( mapName );			this.globalEventXML = TinyMapLookup.getMapEventXMLFromName( 'GLOBAL' );						// Add 'em up			this.addChild( this.mapBase );			this.addChild( this.mapHit );			this.addChild( this.mapObjects );			this.addChild( this.mapMiscCollisionContainer );			this.addChild( this.mapUserObjects );						// Dispatch the map's ready event after one frame if there are no NPCs or sprites to wait for. 			// Otherwise, we wait for the NPCs and sprites to be ready before dispatching this event 			// in the onNPCDataReady() or onSpriteDataReady() functions. 			if ( this.npcReadyCount == 0 && this.spriteReadyCount == 0 ) 			{				TweenLite.delayedCall( 1, this.dispatchEvent, [ new TinyFieldMapEvent( TinyFieldMapEvent.DATA_READY ) ], true );			}		}						/**		 * Event listener for TinyFieldMapEvent.DATA_READY, called by each NPC after it is initialized.		 * If this is the last map object to be initialized, this will dispatch the DATA_READY event for the entire map.		 * 		 * @param	event	the {@link TinyFieldMapEvent} instance  		 */		private function onNPCDataReady( event : TinyFieldMapEvent ) : void		{			var npcObject : TinyFieldMapObjectNPC = event.param as TinyFieldMapObjectNPC; 						TinyLogManager.log( 'adding NPC: ' + npcObject.npcName, this );						// Cleanup			npcObject.removeEventListener( TinyFieldMapEvent.DATA_READY, this.onNPCDataReady );			// Add to NPC array			this.npcArray.push( npcObject );						// Add the NPC's hitbox to the objects and walls collision groups			this.addToCollisionGroup( npcObject.hitbox, COLLISION_TYPE_OBJECTS );			this.addToCollisionGroup( npcObject.hitbox, COLLISION_TYPE_WALLS );						// If the NPC is a trainer, add their sight hitbox to the objects collision group			if ( npcObject.isTrainer ) 			{				this.addToCollisionGroup( npcObject.sightBox, COLLISION_TYPE_OBJECTS );			}						// Dispatch the map's ready event when all NPCs and sprites are accounted for 			if ( this.npcArray.length == this.npcReadyCount && this.spriteArray.length == this.spriteReadyCount )			{				this.dispatchEvent( new TinyFieldMapEvent( TinyFieldMapEvent.DATA_READY ) );				}		}						/**		 * Event listener for TinyFieldMapEvent.DATA_READY, called by each sprite after it is initialized.		 * If this is the last map object to be initialized, this will dispatch the DATA_READY event for the entire map.		 * 		 * @param	event	the TinyFieldMapEvent instance 		 */			private function onSpriteDataReady( event : TinyFieldMapEvent ) : void		{			var spriteObject : TinyFieldMapObjectSprite = event.param as TinyFieldMapObjectSprite;						TinyLogManager.log( 'adding sprite: ' + spriteObject.spriteName, this );						// Cleanup			spriteObject.removeEventListener( TinyFieldMapEvent.DATA_READY, this.onSpriteDataReady );			// Add to sprite array			this.spriteArray.push( spriteObject );						// Dispatch the map's ready event when all NPCs and sprites are accounted for 			if ( this.npcArray.length == this.npcReadyCount && this.spriteArray.length == this.spriteReadyCount ) 			{				this.dispatchEvent( new TinyFieldMapEvent( TinyFieldMapEvent.DATA_READY ) );			}		}						/**		 * Adds a given object to a given collision group. Valid collision groups are:		 * 		 * - COLLISION_TYPE_WALLS:		impassable		 * - COLLISION_TYPE_GRASS:		passable, potential wild mon encounter		 * - COLLISION_TYPE_JUMPS:		passable in specific direction, player can jump over them		 * - COLLISION_TYPE_OBJECTS:	impassable, can trigger an event		 * - COLLISION_TYPE_DISABLE:	impassable in a specific direction		 * 		 * @param object	the object to be added		 * @param type		the type of collision group to add the object to 		 */		public function addToCollisionGroup( object : DisplayObject, type : String = COLLISION_TYPE_WALLS ) : void		{			switch ( type ) 			{				default:				case COLLISION_TYPE_WALLS:		this.collisionWalls.addItem( object ); break;				case COLLISION_TYPE_GRASS:		this.collisionGrass.addItem( object ); break;				case COLLISION_TYPE_JUMPS:		this.collisionJumps.addItem( object ); break;				case COLLISION_TYPE_OBJECTS:	this.collisionObjects.addItem( object ); break;				case COLLISION_TYPE_DISABLE:	this.collisionDisable.addItem( object ); break;			}		}						/**		 * Removes a given object from a given collision group. Valid collision groups are:		 * 		 * - COLLISION_TYPE_WALLS:		impassable		 * - COLLISION_TYPE_GRASS:		passable, potential wild mon encounter		 * - COLLISION_TYPE_JUMPS:		passable in specific direction, player can jump over them		 * - COLLISION_TYPE_OBJECTS:	impassable, can trigger an event		 * - COLLISION_TYPE_DISABLE:	impassable in a specific direction		 * 		 * @param object	the object to be removed		 * @param type		the type of collision group to remove the object from 		 */		public function removeFromCollisionGroup( object : DisplayObject, type : String = COLLISION_TYPE_WALLS ) : void		{			switch ( type ) 			{				default:				case COLLISION_TYPE_WALLS:		this.collisionWalls.removeItem( object ); break;				case COLLISION_TYPE_GRASS:		this.collisionGrass.removeItem( object ); break;				case COLLISION_TYPE_JUMPS:		this.collisionJumps.removeItem( object ); break;				case COLLISION_TYPE_OBJECTS:	this.collisionObjects.removeItem( object ); break;				case COLLISION_TYPE_DISABLE:	this.collisionDisable.removeItem( object ); break;			}		}						/**		 * Tests a given object against the WALLS collision group and returns the result.		 * 		 * @param 	object	the object to test		 * @return			the collision result object 		 */		public function checkWallCollision( object : DisplayObject ) : TinyCollisionData		{				return this.collisionWalls.checkCollision( object );		}						/**		 * Tests a given object against the GRASS collision group and returns the result.		 * 		 * @param 	object	the object to test		 * @return			the collision result object 		 */		public function checkGrassCollision( object : DisplayObject ) : TinyCollisionData 		{			return this.collisionGrass.checkCollision( object );		}						/**		 * Tests a given object against the JUMPS collision group and returns the result.		 * 		 * @param 	object	the object to test		 * @return			the collision result object 		 */		public function checkJumpCollision( object : DisplayObject ) : TinyCollisionData 		{			return this.collisionJumps.checkCollision( object );		}						/**		 * Tests a given object against the OBJECTS collision group and returns the result.		 * 		 * @param 	object	the object to test		 * @return			the collision result object 		 */		public function checkObjectCollision( object : DisplayObject ) : TinyCollisionData		{				return this.collisionObjects.checkCollision( object );		}						/**		 * Tests a given object against the DISABLE collision group and returns the result.		 * 		 * @param 	object	the object to test		 * @return			the collision result object 		 */		public function checkDisableCollision( object : DisplayObject ) : TinyCollisionData 		{			return this.collisionDisable.checkCollision( object );		}						/**		 * Attempts to start a wild encounter using the map's encounter data. 		 * 		 * @return	a mon if the encounter is successful, null otherwise		 */		public function tryWildEncounter() : TinyMon		{			// Repels prevent all wild encounters			if ( TinyGameManager.getInstance().playerTrainer.usedRepel ) return null;						if ( TinyMath.randomInt( 0, 255 ) < this.encounterRate )			{				return this.encounterData.getEncounterMon();						}						return null;		}				 		/** 		 * Starts an event with a given name. Passing true as the second parameter will look for the event  		 * in the global event XML file, which has events used by multiple maps. 		 *  		 * @param 	eventName 	the name of the event. Must match an event name in the map's event XML  		 * 						file or the global event XML file. 		 * @param	isGlobal	whether or not to use the global event list. 		 */		public function startEventByName( eventName : String, isGlobal : Boolean = false ) : void		{			TinyLogManager.log( 'startEventByName: ' + eventName, this );						if ( isGlobal ) TinyLogManager.log( 'using the global events', this );						// Create the new event sequence			this.currentEventSequence = TinyEventSequence.newFromEventName( ( isGlobal ? this.globalEventXML : this.eventXML ), eventName );						// Add the sequence to the map manager's event container sprite			TinyMapManager.getInstance().mapEventContainer.addChild( this.currentEventSequence );						// Start the event sequence			this.currentEventSequence.addEventListener( Event.COMPLETE, this.onEventSequenceComplete );			this.currentEventSequence.startSequence();		}		/**		 * Listner for Event.COMPLETE events from the current event sequence. Removes any sprites		 * spawned by the event and tells the {@link TinyMapManager} that the event is complete.		 * 		 * @see TinyMapManager 		 */		private function onEventSequenceComplete( event : Event ) : void 		{			TinyLogManager.log( 'onEventSequenceComplete', this );						// Remove the sequence from the map manager's event container sprite			TinyMapManager.getInstance().mapEventContainer.removeChild( this.currentEventSequence );						// Get the restoreControl and eventName values from the event sequence before it is cleared.			// These values will be used during warp event commands in the MapManager. 			var restoreControl : Boolean = this.currentEventSequence.restoreControl;			var eventName : String = this.currentEventSequence.eventName;						// Resume any random NPC spinning			for ( var i : uint = 0; i < this.npcArray.length; i++ ) 			{				this.npcArray[ i ].enableSpin = true;				this.npcArray[ i ].tryRestartSpin();			}						// Clean up			this.currentEventSequence.removeEventListener( Event.COMPLETE, this.onEventSequenceComplete );			this.currentEventSequence = null;						// Alert the TinyMapManager that the event is complete			this.dispatchEvent( new TinyFieldMapEvent( TinyFieldMapEvent.EVENT_COMPLETE, {				eventName: eventName,				restoreControl: restoreControl			}));		}						/**		 * Returns a map object with a given name.		 * 		 * @param	objectName	the name of the object to find		 * @return				the found object, or null if nothing is found		 */		public function getMapObjectByName( objectName : String ) : DisplayObject		{			return this.mapObjects.getChildByName( objectName );		}										/**		 * Returns a {@link TinyFieldMapObjectSprite} object in the map with a given name.		 * 		 * @param 	targetName	the name of the sprite object to find		 * @return				the found object, or null if nothing is found		 */		public function getSpriteObjectByName( targetName : String ) : TinyFieldMapObjectSprite		{			TinyLogManager.log( 'getSpriteObjectByName: ' + targetName, this );						var findByNameFunction : Function = function( item : *, index : int, array : Array ) : Boolean			{ 					// Use mandatory variables to prevent compiler warnings				index;				array; 								return ( item as TinyFieldMapObjectSprite ).spriteName.toUpperCase() == targetName.toUpperCase(); 			};						// Search for a sprite object with a matching name			return this.spriteArray.filter( findByNameFunction )[ 0 ];		}		/**		 * Returns a {@link TinyFieldMapObjectNPC} object in the map with a given name.		 * 		 * @param 	targetName	the name of the NPC object to find		 * @return				the found object, or null if nothing is found		 */		public function getNPCObjectByName( targetName : String ) : TinyFieldMapObjectNPC		{			TinyLogManager.log( 'getNPCObjectByName: ' + targetName, this );						var findByNameFunction : Function = function( item : *, index : int, array : Array ) : Boolean			{ 					// Use mandatory variables to prevent compiler warnings				index;				array; 								return ( item as TinyFieldMapObjectNPC ).npcName.toUpperCase() == targetName.toUpperCase(); 			};						// Search for an npc object with a matching name			return this.npcArray.filter( findByNameFunction )[ 0 ];		}						/**		 * Adds a given {@link TinyFieldMapObjectNPC} to the map.		 * 		 * @param 	npcObject	the NPC to add to the map		 */		public function addNPCObject( npcObject : TinyFieldMapObjectNPC ) : void		{			TinyLogManager.log( 'addNPCObject: ' + npcObject.npcName, this );				// Add NPC to collision groups				this.addToCollisionGroup( npcObject.hitbox, COLLISION_TYPE_OBJECTS );			this.addToCollisionGroup( npcObject.hitbox, COLLISION_TYPE_WALLS );						// Add 'em up						this.mapObjects.addChild( npcObject );			this.npcArray.push( npcObject );		}						/**		 * Removes an NPC object with a given name from the map.		 * 		 * @param	npcName		the name of the NPC object to remove from the map.		 */		public function removeNPCByName( npcName : String ) : void		{			TinyLogManager.log( 'removeNPCByName: ' + npcName, this );						// Find the NPC with the given name			var npcToRemove : TinyFieldMapObjectNPC = this.getNPCObjectByName( npcName );						if ( !npcToRemove ) 			{				TinyLogManager.log( 'removeNPCByName: ERROR - could not find an NPC with the name ' + npcName, this );				return;				}						npcToRemove.walkSprite.isAlive = false;						// Remove hitbox from collision lists			this.removeFromCollisionGroup( npcToRemove.hitbox, COLLISION_TYPE_OBJECTS );			this.removeFromCollisionGroup( npcToRemove.hitbox, COLLISION_TYPE_WALLS );						// If the NPC is a trainer, remove sightbox from collision list			if ( npcToRemove.isTrainer && npcToRemove.sightBox ) 			{				this.removeFromCollisionGroup( npcToRemove.sightBox, COLLISION_TYPE_OBJECTS );			}						// Remove from display list				this.mapObjects.removeChild( npcToRemove );						// Remove from the NPC array			this.npcArray.splice( this.npcArray.indexOf( npcToRemove ), 1 );		}						/**		 * Removes a trigger object with a given name from the map.		 * 		 * @param	triggerName		the name of the trigger object to remove from the map.		 */		public function removeTriggerByName( triggerName : String ) : void		{			TinyLogManager.log( 'removeTriggerByName: ' + triggerName, this );						// Find the trigger with the given name			var triggerToRemove : TinyFieldMapObjectTrigger = this.mapObjects.getChildByName( triggerName ) as TinyFieldMapObjectTrigger;						if ( !triggerToRemove ) 			{				TinyLogManager.log( 'removeTriggerByName: ERROR - could not find a trigger with the name ' + triggerName, this );				return;				}						// Remove from collision list			this.removeFromCollisionGroup( triggerToRemove.hitbox, COLLISION_TYPE_OBJECTS );						// Remove from display list				this.mapObjects.removeChild( triggerToRemove );		}						/**		 * Removes a warp object with a given name from the map.		 * 		 * @param	warpName		the name of the warp object to remove from the map.		 */		public function removeWarpByName( warpName : String ) : void		{			TinyLogManager.log( 'removeWarpByName: ' + warpName, this );						// Find the warp with the given name			var warpToRemove : TinyFieldMapObjectWarp = this.mapObjects.getChildByName( warpName ) as TinyFieldMapObjectWarp;						if ( !warpToRemove ) 			{				TinyLogManager.log( 'removeWarpByName: ERROR - could not find a warp with the name ' + warpName, this );				return;				}						// Remove from collision list			this.removeFromCollisionGroup( warpToRemove.hitbox, COLLISION_TYPE_OBJECTS );						// Remove from display list				this.mapObjects.removeChild( warpToRemove );		}						/**		 * Deactivates an NPC trainer with a given name, which just removes their sightbox. 		 * 		 * @param	trainerName		the name of the NPC trainer to deactivate		 */		public function disableTrainerByName( trainerName : String ) : void		{			TinyLogManager.log( 'deactivateTrainerByName: ' + trainerName, this );						// Find the trainer with the given name			var trainerToDeactivate : TinyFieldMapObjectNPC = this.getNPCObjectByName( trainerName );						if ( !trainerToDeactivate ) 			{				TinyLogManager.log( 'deactivateTrainerByName: ERROR - could not find a trainer with the name ' + trainerName, this );				return;			}						if ( !trainerToDeactivate.isTrainer )			{				TinyLogManager.log( 'deactivateTrainerByName: ERROR - NPC with the name ' + trainerName + ' is not a trainer', this );				return;			}						// Remove the NPC's sightbox from the collision group			this.removeFromCollisionGroup( trainerToDeactivate.sightBox, COLLISION_TYPE_OBJECTS );						// Deactivate the NPC's trainer state entirely			trainerToDeactivate.deactivateTrainer();		}	}}