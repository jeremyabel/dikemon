package com.tinyrpg.core {		import com.coreyoneil.collision.CollisionGroup;	import com.tinyrpg.battle.TinyBattleMon;	import com.tinyrpg.data.TinyCollisionData;	import com.tinyrpg.display.TinyMapMovieClip;	import com.tinyrpg.events.TinyFieldMapEvent;	import com.tinyrpg.managers.TinyMapManager;//	import com.tinyrpg.display.TinySpriteSheet;//	import com.tinyrpg.managers.TinyAudioManager;	import com.tinyrpg.misc.TinyMapConfig;	import com.tinyrpg.utils.TinyLogManager;//	import com.tinyrpg.utils.TinyMath;	import flash.display.BlendMode;	import flash.display.DisplayObject;	import flash.display.MovieClip;	import flash.display.Sprite;	import flash.events.Event;	import flash.geom.Point;	import flash.utils.ByteArray;	/**	 * @author jeremyabel	 */	public class TinyFieldMap extends Sprite 	{		public static const COLLISION_TYPE_WALLS	: String = 'WALLS';		public static const COLLISION_TYPE_OBJECTS	: String = 'OBJECTS'; 		//		public static var TILE_SIZE 		: uint = 16;//		public static var hitLayer			: MovieClip;//		public static var npcArray			: Array = [];//		public static var mapName			: String;//		public static var inBattle			: Boolean = false;//		public static var encounterCount	: int = 0;//		public static var evilLevel			: int = 1;			public var mapUserObjects			: Sprite;		public var startingEventName		: String;		private var mapMovieClip			: TinyMapMovieClip;		private var showHideCover			: Sprite;		private var eventXML 				: XML;		private var currentEventSequence	: TinyEventSequence;		private var currentBattle			: TinyBattleMon;		private var mapObjects				: MovieClip;		private var mapBase					: MovieClip;		private var mapHit					: MovieClip;		private var collisionWalls 			: CollisionGroup;		private var collisionObjects		: CollisionGroup;		public function TinyFieldMap( mapName : String ) : void		{			this.mapMovieClip = TinyMapConfig.getMapFromName( mapName );			this.mapBase = this.mapMovieClip.map;			this.mapHit = this.mapMovieClip.hit;			this.mapHit.visible = false;						this.mapObjects = this.mapMovieClip.objects;			this.mapUserObjects = new Sprite();						// Collision groups			this.collisionWalls = new CollisionGroup( this.mapHit );			this.collisionObjects = new CollisionGroup();						// Add each map object to the objects collision group			for ( var i : uint = 0; i < this.mapObjects.numChildren; i++ )			{				var mapObject : DisplayObject = this.mapObjects.getChildAt( i );				this.addToCollisionGroup( mapObject, COLLISION_TYPE_OBJECTS );			}						// Get event sequencer list			this.eventXML = TinyMapConfig.getMapEventXMLFromName( mapName );						// Add 'em up			this.addChild( this.mapBase );			this.addChild( this.mapHit );			this.addChild( this.mapObjects );			this.addChild( this.mapUserObjects );		}				public function addToCollisionGroup( object : DisplayObject, type : String = COLLISION_TYPE_WALLS ) : void		{			switch ( type ) 			{				default:				case COLLISION_TYPE_WALLS:					this.collisionWalls.addItem( object );					break;								case COLLISION_TYPE_OBJECTS:					this.collisionObjects.addItem( object );					break;			}		}				public function checkWallCollision( object : DisplayObject ) : TinyCollisionData		{				return this.collisionWalls.checkCollision( object );		}				public function checkObjectCollision( object : DisplayObject ) : TinyCollisionData		{				return this.collisionObjects.checkCollision( object );		}				public function getMapObjectByName( objectName : String ) : DisplayObject		{			return this.mapObjects.getChildByName( objectName );		}		//		public function addNPCSpriteAt(npcSprite : TinyFriendSprite, x : int, y : int, facing : String = 'DOWN') : void//		{//			TinyLogManager.log('addNPCSpriteAt: ' + npcSprite.charName, this);//			//			// If this is the player sprite, add Green instead//			var newSprite : TinyFriendSprite;//			if (npcSprite.charName.toUpperCase() == TinyPlayer.getInstance().playerName.toUpperCase() && !TinyEventFlagData.getInstance().getFlagByName('has_green').value) {//				TinyLogManager.log('replacing player sprite with GREEN', this);//				newSprite = TinyFriendSprite.newFromName('GREEN');//				newSprite.event = 'green_talk';//			} else {//				if (TinyEventFlagData.getRecruitFlagByName(npcSprite.charName)) { //					if (TinyEventFlagData.getRecruitFlagByName(npcSprite.charName.toUpperCase()).value && TinyFieldMap.mapName.toUpperCase() != 'MAP_COMPUTER_ROOM') {//						return;//					}//				}//				newSprite = npcSprite;//			}////			// Oh, and don't add the "space marine" if we're Ron//			if (npcSprite.charName.toUpperCase() == 'SPACE MARINE' && TinyPlayer.getInstance().playerName == 'RON') {//				return;//			}//				//			// Make new sprite//			newSprite.x = x;//			newSprite.y = y;//			newSprite.facing =//			newSprite.defaultFacing = facing;//			newSprite.idleWalk();//			//			// Add 'em up//			this.mapHolder.addChild(newSprite);//			TinyFieldMap.objectArray.push(newSprite);//			TinyFieldMap.npcArray.push(newSprite);//			//			// Add sprites to collision list - try is for if the collisionList hasn't been made yet//			try { TinyFieldMap.collisionList.addItem(newSprite.hitBox); } catch (error : Error) { } //		}		//		public function removeNPCSprite(spriteName : String) : void//		{//			TinyLogManager.log('removeNPCSprite: ' + spriteName, this);//			//			// Find the sprite//			var targetSprite : TinyFriendSprite = TinyFieldMap.getNPCSpriteByName(spriteName);//			//			if (spriteName.toUpperCase() == TinyPlayer.getInstance().playerName.toUpperCase()) {//				targetSprite = TinyFriendSprite(TinyStatsEntity(TinyPlayer.getInstance().fullParty.getCharByName(spriteName)).graphics);//			}//			//			// Remove and clean up, or at least act like you are...//			try {//				this.mapHolder.removeChild(targetSprite);//				TinyFieldMap.collisionList.removeItem(targetSprite.hitBox);//				TinyFieldMap.npcArray.splice(TinyFieldMap.npcArray.indexOf(targetSprite), 1);  //				TinyFieldMap.objectArray.splice(TinyFieldMap.objectArray.indexOf(targetSprite), 1);//				targetSprite = null;//			} catch (error : Error) {//				try {//					targetSprite.visible = false;//				} catch (error : Error) {//					// GOD I HATE THIS THING!!//					TinyFriendSprite(TinyStatsEntity(TinyPlayer.getInstance().fullParty.getCharByName('ASA')).graphics).visible = false;//					TinyFriendSprite(TinyStatsEntity(TinyPlayer.getInstance().fullParty.getCharByName('ANDY')).graphics).visible = false;//					TinyFriendSprite(TinyStatsEntity(TinyPlayer.getInstance().fullParty.getCharByName('JASON')).graphics).visible = false;//					TinyFriendSprite(TinyStatsEntity(TinyPlayer.getInstance().fullParty.getCharByName('MEGAN')).graphics).visible = false;//					TinyFriendSprite(TinyStatsEntity(TinyPlayer.getInstance().fullParty.getCharByName('RACHEL')).graphics).visible = false;//					TinyFriendSprite(TinyStatsEntity(TinyPlayer.getInstance().fullParty.getCharByName('RALPH')).graphics).visible = false;//					TinyFriendSprite(TinyStatsEntity(TinyPlayer.getInstance().fullParty.getCharByName('RON')).graphics).visible = false;//				}//			}//			//			// Reset last touched for player//			TinyFriendSprite(TinyStatsEntity(TinyPlayer.getInstance().fullParty.party[0]).graphics).lastTouch = '';//		}				public function doRandomEncounter() : void		{//			TinyLogManager.log('========================', this);//			TinyLogManager.log('   RANDOM ENCOUNTER!', this);//			TinyLogManager.log('========================', this);//			//			// Remove control//			TinyInputManager.getInstance().setTarget(null);//			//			var totalLevels : int = 0;//			var levelCount  : int = 0;//			//			// Use average level to determine enemy set to fight//			for each (var char : TinyStatsEntity in TinyPlayer.getInstance().party.party) {//				totalLevels += char.stats.LVL;//				levelCount++;//			}//			//			// Average party level//			var avgLevel : int = Math.round(totalLevels / levelCount);//			//			// Determine which set of enemies to pull from//			var levelSet : int;//			if (avgLevel == 1 || avgLevel == 2) //				levelSet = 0;//			else if (avgLevel == 3 || avgLevel == 4)//				levelSet = 1;//			else if (avgLevel >= 5 && avgLevel <= 7) //				levelSet = 2;//			else if (avgLevel >= 8 && avgLevel <= 10)//				levelSet = 3;//			else if (avgLevel >= 11 && avgLevel <= 14)//				levelSet = 4;//			else if (avgLevel >= 15)//				levelSet = 5;//			//			var levelSetArray : Array = TinyEnemyDataList.getInstance().levelList[levelSet];//			//			// How many enemies will we fight?//			var howManyEnemies : int = 1;//			//			// For parties of two//			var rand : int = TinyMath.randomInt();//			if (TinyPlayer.getInstance().party.party.length == 2) //			{	//				// 38% chance of getting two enemies//				if (rand >= 38) {//					howManyEnemies = 2;//				}//			}//			//			// For parties of three//			if (TinyPlayer.getInstance().party.party.length == 3) //			{//				// 65% chance of getting three enemies, default to two//				if (rand >= 75) {//					//howManyEnemies = 3;//					howManyEnemies = 2;//				} else {//					howManyEnemies = 2;//				}//			}//			//			// Pick enemies//			var pickedNumbers : Array = [];//			var enemies : Array = [];//			for (var i : int = 0; i < howManyEnemies; i++) {//				var rand2 : int = TinyMath.randomInt(0, levelSetArray.length);//				while (pickedNumbers.indexOf(rand2) != -1) {//					rand2 = TinyMath.randomInt(0, levelSetArray.length - 1);//				}//				pickedNumbers.push(rand2);//				enemies.push(TinyEnemyDataList.getInstance().getEnemyByName(levelSetArray[rand2]));//			}//			//			TinyFieldMap.inBattle = true;//			//			// Start battle//			this.currentBattle = new TinyBattle(enemies, true);//			this.currentBattle.addEventListener(Event.COMPLETE, onBattleComplete);//			this.addChild(this.currentBattle);//			this.currentBattle.startBattle();		}		private function onBattleComplete(event : Event) : void 		{			TinyLogManager.log('onBattleComplete', this);			//			// Clean up//			TinyInputManager.getInstance().setTarget(null);//			this.currentBattle.removeEventListener(Event.COMPLETE, onBattleComplete);//			this.removeChild(this.currentBattle);//			this.currentBattle = null;//			//			// If we're doing Andy's quest, display gore paint message//			if (TinyEventFlagData.getInstance().getFlagByName('andy_talked_to').value && !TinyEventFlagData.getInstance().getFlagByName('andy_quest_done').value && !TinyEventFlagData.getRecruitFlagByName('ANDY').value) {//				this.addEventSequence('andy_gore_paint');//				this.startCurrentEvent();//			} else {//				// Return control to the player//				TinyInputManager.getInstance().setTarget(TinyFriendSprite(TinyStatsEntity(TinyPlayer.getInstance().party.party[0]).graphics));//			}//			//			// Restore music//			TinyAudioManager.getInstance().setSong(TinyAudioManager.getMusicByMapName(TinyFieldMap.mapName), true);		}//		public function addEventSequence(eventName : String) : void//		{//			TinyLogManager.log('addEventSequence: ' + eventName, this);//			//			this.currentEvent = TinyEventSequence.newFromEventName(eventName);//		}//				public function startEventByName( eventName : String ) : void		{			TinyLogManager.log( 'startEventByName: ' + eventName, this );						// Create and start the new event sequence			this.currentEventSequence = TinyEventSequence.newFromEventName( this.eventXML, eventName );			this.currentEventSequence.addEventListener( Event.COMPLETE, this.onEventSequenceComplete );			this.currentEventSequence.startSequence();						// Add the sequence to the map manager's event container sprite			TinyMapManager.getInstance().mapEventContainer.addChild( this.currentEventSequence );		}		private function onEventSequenceComplete( event : Event ) : void 		{			TinyLogManager.log( 'onEventSequenceComplete', this );						// Remove the sequence from the map manager's event container sprite			TinyMapManager.getInstance().mapEventContainer.removeChild( this.currentEventSequence );						// Clean up			this.currentEventSequence.removeEventListener( Event.COMPLETE, this.onEventSequenceComplete );			this.currentEventSequence = null;						// Alert the map manager that the event is complete			this.dispatchEvent( new TinyFieldMapEvent( TinyFieldMapEvent.EVENT_COMPLETE ) );		}		//		public static function getNPCSpriteByName(targetName : String) : TinyFriendSprite//		{//			TinyLogManager.log('getNPCSpriteByName: ' + targetName, TinyFieldMap);//			//			// Find function//			var findFunction : Function = function(item : *, index : int, array : Array) : Boolean//				{ index; array; return (TinyFriendSprite(item).charName.toUpperCase() == targetName.toUpperCase()); };//			//			// Search for character//			return TinyFieldMap.npcArray.filter(findFunction)[0];//		}			}}