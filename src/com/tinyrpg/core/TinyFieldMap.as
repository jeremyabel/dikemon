package com.tinyrpg.core {		import com.coreyoneil.collision.CollisionGroup;	import com.greensock.TweenLite;//	import com.greensock.easing.SteppedEase;	import com.tinyrpg.data.TinyCollisionData;	import com.tinyrpg.data.TinyFieldMapObjectNPC;	import com.tinyrpg.data.TinyFieldMapObjectTrainer;	import com.tinyrpg.data.TinyFieldMapObjectTrigger;	import com.tinyrpg.data.TinyFieldMapObjectWarp;//	import com.tinyrpg.data.TinyAppSettings;//	import com.tinyrpg.data.TinyEnemyDataList;//	import com.tinyrpg.data.TinyEventFlagData;//	import com.tinyrpg.display.TinyBunny;//	import com.tinyrpg.display.TinyEnding;	import com.tinyrpg.display.TinyMapMovieClip;//	import com.tinyrpg.display.TinySpriteSheet;	import com.tinyrpg.events.TinyFieldMapEvent;//	import com.tinyrpg.managers.TinyAudioManager;//	import com.tinyrpg.managers.TinyInputManager;//	import com.tinyrpg.maps.TinyCastleMap;	import com.tinyrpg.misc.TinyMapConfig;//	import com.tinyrpg.ui.TinyGameMenu;	import com.tinyrpg.utils.TinyLogManager;//	import com.tinyrpg.utils.TinyMath;	import flash.display.BlendMode;	import flash.display.DisplayObject;	import flash.display.MovieClip;	import flash.display.Sprite;	import flash.events.Event;	import flash.geom.Point;	import flash.utils.ByteArray;	/**	 * @author jeremyabel	 */	public class TinyFieldMap extends Sprite 	{		public static const COLLISION_TYPE_WALLS	: String = 'WALLS';		public static const COLLISION_TYPE_OBJECTS	: String = 'OBJECTS'; //		[Embed(source='../../../../bin/xml/Maps.xml', mimeType='application/octet-stream')]//		public const Map_Data : Class;		//		private static var instance		: TinyFieldMap = new TinyFieldMap();//		public static var TILE_SIZE 		: uint = 16;//		public static var hitLayer			: MovieClip;//		public static var npcArray			: Array = [];//		public static var objectArray 		: Array = [];//		public static var objectEvents		: Array = [];//		public static var mapName			: String;//		public static var currentMap		: TinyMapMovieClip;//		public static var inBattle			: Boolean = false;//		public static var encounterCount	: int = 0;//		public static var evilLevel			: int = 1;			public var mapUserObjects		: Sprite;		//		public  var startingEventName	: String;		private var mapMovieClip		: TinyMapMovieClip;		private var showHideCover		: Sprite;//		private var eventSpriteHolder   : Sprite;//		private var currentEvent		: TinyEventSequence;//		private var currentBattle		: TinyBattle;//		private var doingEvent			: Boolean = false;		private var mapObjects			: MovieClip;		private var mapBase				: MovieClip;//		private var mapOverlay			: MovieClip;		private var mapHit				: MovieClip;		private var collisionWalls 		: CollisionGroup;		private var collisionObjects	: CollisionGroup;//		private var mapHolder			: Sprite;//		private var gameMenu			: TinyGameMenu;//		private var oldY				: int;//		private var bigBlackSprite		: Sprite;//		private var mapXMLData 			: XML;//		private var northMapName		: String;//		private var northEventName		: String;//		private var northExitOffset		: int;//		private var southMapName		: String;//		private var southEventName		: String;//		private var southExitOffset		: int;//		private var eastMapName			: String;//		private var eastEventName		: String;//		private var eastExitOffset		: int;//		private var westMapName			: String;//		private var westEventName		: String;//		private var westExitOffset		: int;//		private var collideThings		: Array = [];		//		private var endSequence 		: Array = [ 'fight_drunk_evan', 'fight_dark_evan_1', 'fight_dark_evan_2' ];//		private var endGame 			: Boolean = false;		
//		private var testOrigin1			: Sprite;
//		private var testOrigin2			: Sprite;
		public function TinyFieldMap( mapName : String ) : void //, fromLoadGame : Boolean = false ) : void		{			this.mapMovieClip = TinyMapConfig.getMapFromName( mapName );			this.mapBase = this.mapMovieClip.map;			this.mapHit = this.mapMovieClip.hit;			this.mapHit.visible = false;						this.mapObjects = this.mapMovieClip.objects;			this.mapUserObjects = new Sprite();						// Collision groups			this.collisionWalls = new CollisionGroup( this.mapHit );			this.collisionObjects = new CollisionGroup();						// Add each map object to the objects collision group			for ( var i : uint = 0; i < this.mapObjects.numChildren; i++ )			{				var mapObject : DisplayObject = this.mapObjects.getChildAt( i );				this.addToCollisionGroup( mapObject, COLLISION_TYPE_OBJECTS );			}						// Add 'em up			this.addChild( this.mapBase );			this.addChild( this.mapHit );			this.addChild( this.mapObjects );			this.addChild( this.mapUserObjects );						// Get map data from XML//			var byteArray : ByteArray = new this.Map_Data() as ByteArray;//			var string : String = byteArray.readUTFBytes(byteArray.length);//			this.mapXMLData = new XML(string);			//trace(this.mapXMLData.toXMLString());		}				public function addToCollisionGroup( object : DisplayObject, type : String = COLLISION_TYPE_WALLS ) : void		{			switch ( type ) 			{				default:				case COLLISION_TYPE_WALLS:					this.collisionWalls.addItem( object );					break;								case COLLISION_TYPE_OBJECTS:					this.collisionObjects.addItem( object );					break;			}		}				public function checkWallCollision( object : DisplayObject ) : TinyCollisionData		{				return this.collisionWalls.checkCollision( object );		}				public function checkObjectCollision( object : DisplayObject ) : TinyCollisionData		{				return this.collisionObjects.checkCollision( object );		}				public function getMapObjectByName( objectName : String ) : DisplayObject		{			return this.mapObjects.getChildByName( objectName );		}		//		public function setMap( map : TinyMapMovieClip, fromLoadGame : Boolean, silent : Boolean = false ) : void//		{//			TinyLogManager.log('set map', this);//			//			// Set map name//			TinyFieldMap.mapName = TinyMapConfig.getMapNameFromClip(map);//			TinyFieldMap.currentMap = map;//			//			// Play song//			TinyAudioManager.getInstance().setSong(TinyAudioManager.getMusicByMapName(TinyFieldMap.mapName), true);//			//			if (silent) {//				TinyAudioManager.getInstance().stopMusic();//			}			//			// Get map pieces//			this.mapBase = map.MAP;//			this.mapHit = map.HIT;////			if (map.OVERLAY) { this.mapOverlay = map.OVERLAY; }//			//			this.mapHolder = new Sprite;//			//			// Add 'em up//			this.addChild(this.mapBase);//			this.addChild(this.mapHolder);//			this.addChild(this.mapHit);//			//			if (map.OVERLAY) { this.addChild(this.mapOverlay); }//			this.addChild(this.eventSpriteHolder);//			//			// Put the menu in front//			this.setChildIndex(this.gameMenu, this.numChildren - 1);			//			// Move objects we placed in the IDE onto the main stage//			if (map.OBJECTS) {//				if (map.OBJECTS.numChildren > 0) {//					while (map.OBJECTS.numChildren > 0) //					{//						TinyLogManager.log('found object: ' + map.OBJECTS.getChildAt(0).name, this);//						//						if ((TinyFieldMap.mapName.toUpperCase() != 'MAP_CASTLE_ENTRANCE') || //							(TinyFieldMap.mapName.toUpperCase() == 'MAP_CASTLE_ENTRANCE' && TinyEventFlagData.getInstance().getFlagByName('first_battle_done').value && !TinyEventFlagData.getRecruitFlagByName('FISH').value) || //							map.OBJECTS.getChildByName('EVENT_DOORS')) //						{//							var newObject : DisplayObject = map.OBJECTS.getChildAt(0);//							newObject.x += map.OBJECTS.x;//							newObject.y += map.OBJECTS.y;//							newObject.visible = true;//							//							if (newObject.name == 'EVENT_WEIRD_THING') {//								//MovieClip(newObject['blocker']).visible = false;//								//								if (TinyEventFlagData.getRecruitFlagByName('FISH').value) {//									//MovieClip(newObject['blocker']).alpha = 0;//									newObject.visible = false; //									//newObject.alpha = 0;//								}//							}//							//							this.mapHolder.addChild(newObject);//							TinyFieldMap.objectArray.push(newObject);//						} else {//							break;//						}//					}//				}//			}			//			// Can we talk to any objects?//			var objectXMLData : XMLList = this.mapXMLData.child(TinyFieldMap.mapName.toUpperCase()).child('OBJECTS');//			for each (var object : XML in objectXMLData.children())//			{//				if ((TinyFieldMap.mapName.toUpperCase() != 'MAP_CASTLE_ENTRANCE') || //					(TinyFieldMap.mapName.toUpperCase() == 'MAP_CASTLE_ENTRANCE' && TinyEventFlagData.getInstance().getFlagByName('first_battle_done').value && !TinyEventFlagData.getRecruitFlagByName('FISH').value) ||//					(object.child('NAME').toString() == 'EVENT_DOORS')) //				{//					TinyLogManager.log('adding event object: ' + object.child('NAME').toString(), this);//					//					// Match to object in object array//					TinyFieldMap.objectEvents[object.child('NAME')] = object.child('EVENT');//					//					// Add to list of things to collide with//					if (object.child('NAME').toString() == 'EVENT_DOORS' && TinyEventFlagData.getInstance().getFlagByName('door_opened').value) {////					} else {//						this.collideThings.push(TinyFieldMap.getObjectByName(object.child('NAME')));//					}//					//					// Hide object - we don't need to see it.//					if (object.child('NAME').toString() != 'EVENT_DOORS') {//						TinyFieldMap.getObjectByName(object.child('NAME')).visible = false;//					}//				} else {//					break;//				}//			}//			//			// Set up map hit layer			//			TinyFieldMap.hitLayer = this.mapHit;//			this.mapHit.visible = false;//			//			// Set map exits//			var exitData : XMLList = this.mapXMLData.child(TinyFieldMap.mapName.toUpperCase()).child('EXITS');//			this.northMapName = exitData.child('NORTH').toString();//			this.southMapName = exitData.child('SOUTH').toString();//			this.eastMapName  = exitData.child('EAST').toString();//			this.westMapName  = exitData.child('WEST').toString();//			//			// Set exit offsets//			this.northExitOffset = int(exitData.child('NORTH_OFFSET').toString());//			this.southExitOffset = int(exitData.child('SOUTH_OFFSET').toString());//			this.eastExitOffset  = int(exitData.child('EAST_OFFSET').toString());//			this.westExitOffset  = int(exitData.child('WEST_OFFSET').toString());//			//			// Set map exit events//			this.northEventName = exitData.child('NORTH_EVENT').toString();//			this.southEventName = exitData.child('SOUTH_EVENT').toString();//			this.eastEventName  = exitData.child('EAST_EVENT').toString();//			this.westEventName  = exitData.child('WEST_EVENT').toString();//			//			// Set starting event name//			this.startingEventName = this.mapXMLData.child(TinyFieldMap.mapName.toUpperCase()).child('STARTING_EVENT').toString();//			//			// Disable event for first map//			if (TinyFieldMap.mapName.toUpperCase() == 'MAP_CASTLE_ENTRANCE' && TinyEventFlagData.getInstance().getFlagByName('met_drunk_evan').value) {//				this.northEventName = '';//				this.southEventName = '';//				this.eastEventName =  '';//				this.westEventName =  '';//			}//			//			var npcXMLData : XMLList = this.mapXMLData.child(TinyFieldMap.mapName.toUpperCase()).child('NPCS');//			for each (var npcData : XML in npcXMLData.children())//			{//				var newNPC : TinyFriendSprite = TinyFriendSprite.newFromXML(npcData);//				var npcPos : Point = new Point();//				var npcPosArray : Array = npcData.child('POSITION').toString().split(',');//				npcPos.x = npcPosArray[0];//				npcPos.y = npcPosArray[1];//				this.addNPCSpriteAt(newNPC, npcPos.x, npcPos.y, npcData.child('FACING'));//			}			//			// Do we add a bunny?!//			if ((TinyFieldMap.mapName.toUpperCase() == 'MAP_RON_BASE' || //				TinyFieldMap.mapName.toUpperCase() == 'MAP_ANDY_ROOM' ||//				TinyFieldMap.mapName.toUpperCase() == 'MAP_WEIRD_PLACE' ||//				TinyFieldMap.mapName.toUpperCase() == 'MAP_FISH_PRE_ANTECHAMBER' ||//				TinyFieldMap.mapName.toUpperCase() == 'MAP_FAIR_ENTRANCE')  &&//				!TinyEventFlagData.getInstance().getFlagByName('found_bunny_' + TinyFieldMap.mapName.toUpperCase()).value &&//				!TinyEventFlagData.getInstance().getFlagByName('found_all_bunnies').value && //				 TinyEventFlagData.getInstance().getFlagByName('rachel_bunnies_released').value) //			{//				var newBunny : TinyBunny = new TinyBunny;//				newBunny.event = 'bunny_talk_' + TinyFieldMap.mapName.toUpperCase();//				this.addNPCSpriteAt(newBunny, 160,136, 'LEFT');			//			}//			//			// How evil is this map?//			TinyFieldMap.evilLevel = int(this.mapXMLData.child(TinyFieldMap.mapName.toUpperCase()).child('EVIL_LEVEL').toString());//			//			// Is it really that evil? Decrease level if we have to recruit someone here or if we already have//			var recruitableChar : String = this.getCharacterForMap();//			if (recruitableChar) {//				if (TinyEventFlagData.getRecruitFlagByName(recruitableChar).value) {//					TinyFieldMap.evilLevel = 1;//				} else {//					TinyFieldMap.evilLevel = 0;//				}//			}//			//			// Fade to black sprite//			this.bigBlackSprite = new Sprite;//			this.bigBlackSprite.graphics.beginFill(0);//			this.bigBlackSprite.graphics.drawRect(0, 0, this.mapBase.width, this.mapBase.height);//			this.bigBlackSprite.graphics.endFill();//			this.bigBlackSprite.alpha = 0;//			this.addChild(this.bigBlackSprite);//			//			// Play starting event?//			if (map['event'] && !fromLoadGame && this.startingEventName == '') {//				this.addEventSequence(map['event']);//				this.startCurrentEvent();//			}//		}		public function addPlayerSpriteAt(x : int, y : int) : void		{			TinyLogManager.log('addPlayerSprite', this);			//			TinyFriendSprite(TinyStatsEntity(TinyPlayer.getInstance().party.party[0]).graphics).x = x;//			TinyFriendSprite(TinyStatsEntity(TinyPlayer.getInstance().party.party[0]).graphics).y = y;//			//			this.mapHolder.addChild(TinyFriendSprite(TinyStatsEntity(TinyPlayer.getInstance().party.party[0]).graphics));//			TinyFieldMap.objectArray.push(TinyFriendSprite(TinyStatsEntity(TinyPlayer.getInstance().party.party[0]).graphics));//		//			// Collision//			TinyFieldMap.collisionList = new CollisionGroup(TinyFriendSprite(TinyStatsEntity(TinyPlayer.getInstance().party.party[0]).graphics).hitBox, TinyFieldMap.hitLayer);//			TinyFieldMap.collisionList.returnAngle = true;//			TinyFieldMap.collisionList.returnAngleType = 'DEGREES';//			//			// Add sprites to collision list//			for each (var npcSprite : TinyFriendSprite in TinyFieldMap.npcArray) //				TinyFieldMap.collisionList.addItem(npcSprite.hitBox);//				//			// Add event objects to collision list//			for each (var eventObject : DisplayObject in this.collideThings)//				TinyFieldMap.collisionList.addItem(eventObject);//			//			// Play starting event	//			if (this.startingEventName != '') {//				this.addEventSequence(this.startingEventName);//				this.startCurrentEvent();//			}		}				public function restorePlayerSprite() : void		{			TinyLogManager.log('restorePlayerSprite', this);			//			// Put the player sprite back//			this.mapHolder.addChild(TinyFriendSprite(TinyStatsEntity(TinyPlayer.getInstance().party.party[0]).graphics));		}//		public function addNPCSpriteAt(npcSprite : TinyFriendSprite, x : int, y : int, facing : String = 'DOWN') : void//		{//			TinyLogManager.log('addNPCSpriteAt: ' + npcSprite.charName, this);//			//			// If this is the player sprite, add Green instead//			var newSprite : TinyFriendSprite;//			if (npcSprite.charName.toUpperCase() == TinyPlayer.getInstance().playerName.toUpperCase() && !TinyEventFlagData.getInstance().getFlagByName('has_green').value) {//				TinyLogManager.log('replacing player sprite with GREEN', this);//				newSprite = TinyFriendSprite.newFromName('GREEN');//				newSprite.event = 'green_talk';//			} else {//				if (TinyEventFlagData.getRecruitFlagByName(npcSprite.charName)) { //					if (TinyEventFlagData.getRecruitFlagByName(npcSprite.charName.toUpperCase()).value && TinyFieldMap.mapName.toUpperCase() != 'MAP_COMPUTER_ROOM') {//						return;//					}//				}//				newSprite = npcSprite;//			}////			// Oh, and don't add the "space marine" if we're Ron//			if (npcSprite.charName.toUpperCase() == 'SPACE MARINE' && TinyPlayer.getInstance().playerName == 'RON') {//				return;//			}//				//			// Make new sprite//			newSprite.x = x;//			newSprite.y = y;//			newSprite.facing =//			newSprite.defaultFacing = facing;//			newSprite.idleWalk();//			//			// Add 'em up//			this.mapHolder.addChild(newSprite);//			TinyFieldMap.objectArray.push(newSprite);//			TinyFieldMap.npcArray.push(newSprite);//			//			// Add sprites to collision list - try is for if the collisionList hasn't been made yet//			try { TinyFieldMap.collisionList.addItem(newSprite.hitBox); } catch (error : Error) { } //		}		//		public function removeNPCSprite(spriteName : String) : void//		{//			TinyLogManager.log('removeNPCSprite: ' + spriteName, this);//			//			// Find the sprite//			var targetSprite : TinyFriendSprite = TinyFieldMap.getNPCSpriteByName(spriteName);//			//			if (spriteName.toUpperCase() == TinyPlayer.getInstance().playerName.toUpperCase()) {//				targetSprite = TinyFriendSprite(TinyStatsEntity(TinyPlayer.getInstance().fullParty.getCharByName(spriteName)).graphics);//			}//			//			// Remove and clean up, or at least act like you are...//			try {//				this.mapHolder.removeChild(targetSprite);//				TinyFieldMap.collisionList.removeItem(targetSprite.hitBox);//				TinyFieldMap.npcArray.splice(TinyFieldMap.npcArray.indexOf(targetSprite), 1);  //				TinyFieldMap.objectArray.splice(TinyFieldMap.objectArray.indexOf(targetSprite), 1);//				targetSprite = null;//			} catch (error : Error) {//				try {//					targetSprite.visible = false;//				} catch (error : Error) {//					// GOD I HATE THIS THING!!//					TinyFriendSprite(TinyStatsEntity(TinyPlayer.getInstance().fullParty.getCharByName('ASA')).graphics).visible = false;//					TinyFriendSprite(TinyStatsEntity(TinyPlayer.getInstance().fullParty.getCharByName('ANDY')).graphics).visible = false;//					TinyFriendSprite(TinyStatsEntity(TinyPlayer.getInstance().fullParty.getCharByName('JASON')).graphics).visible = false;//					TinyFriendSprite(TinyStatsEntity(TinyPlayer.getInstance().fullParty.getCharByName('MEGAN')).graphics).visible = false;//					TinyFriendSprite(TinyStatsEntity(TinyPlayer.getInstance().fullParty.getCharByName('RACHEL')).graphics).visible = false;//					TinyFriendSprite(TinyStatsEntity(TinyPlayer.getInstance().fullParty.getCharByName('RALPH')).graphics).visible = false;//					TinyFriendSprite(TinyStatsEntity(TinyPlayer.getInstance().fullParty.getCharByName('RON')).graphics).visible = false;//				}//			}//			//			// Reset last touched for player//			TinyFriendSprite(TinyStatsEntity(TinyPlayer.getInstance().fullParty.party[0]).graphics).lastTouch = '';//		}//		public function transitionToNewMap(newMap : TinyMapMovieClip, entranceDir : String) : void//		{//			TinyLogManager.log('gotoNewMap', this);//			//			TinyFieldMap.mapName = TinyMapConfig.getMapNameFromClip(newMap);//			//			// Longer delay for entrance into final boss chamber//			var delayTime : int = 15;//			if (TinyMapConfig.getMapFromName('MAP_COMPUTER_ROOM') == newMap) {//				delayTime = 34;//			}//			//			// Transition to next song//			TinyAudioManager.getInstance().setSong(TinyAudioManager.getMusicByMapName(TinyFieldMap.mapName), true);//			//			// Fade to black//			TweenLite.to(this.bigBlackSprite, delayTime, { alpha:1, useFrames:true, ease:SteppedEase.create(5), onComplete:this.setNewMap, onCompleteParams:[newMap, entranceDir] });//		}//		//		public function setNewMap(newMap : TinyMapMovieClip, entranceDir : String) : void//		{//			TinyLogManager.log('setNewMap. entering from: ' + entranceDir, this);//			//			TinyFieldMap.currentMap = newMap;//			//TinyFieldMap.encounterCount = 0;//			//			// Set map exits//			var exitData : XMLList = this.mapXMLData.child(TinyFieldMap.mapName.toUpperCase()).child('EXITS');//			this.northMapName = exitData.child('NORTH').toString();//			this.southMapName = exitData.child('SOUTH').toString();//			this.eastMapName  = exitData.child('EAST').toString();//			this.westMapName  = exitData.child('WEST').toString();//			//			// Set exit offsets//			this.northExitOffset = int(exitData.child('NORTH_OFFSET').toString());//			this.southExitOffset = int(exitData.child('SOUTH_OFFSET').toString());//			this.eastExitOffset  = int(exitData.child('EAST_OFFSET').toString());//			this.westExitOffset  = int(exitData.child('WEST_OFFSET').toString());//			//			// Set map exit events//			this.northEventName = exitData.child('NORTH_EVENT').toString();//			this.southEventName = exitData.child('SOUTH_EVENT').toString();//			this.eastEventName  = exitData.child('EAST_EVENT').toString();//			this.westEventName  = exitData.child('WEST_EVENT').toString();//			//			// Set starting event name//			this.startingEventName = this.mapXMLData.child(TinyFieldMap.mapName.toUpperCase()).child('STARTING_EVENT').toString();//			//			// Disable event for first map//			if (TinyFieldMap.mapName.toUpperCase() == 'MAP_CASTLE_ENTRANCE' && TinyEventFlagData.getInstance().getFlagByName('met_drunk_evan').value) {//				this.northEventName = '';//				this.southEventName = '';//				this.eastEventName = '';//				this.westEventName = '';//			}//			//			// Remove old map stuff//			this.removeChild(this.mapBase);//			this.removeChild(this.mapHit);//			this.removeChild(this.eventSpriteHolder);//			this.removeChild(this.mapHolder);//			this.removeChild(this.gameMenu);//			if(this.mapBase['BG']) TinySpriteSheet(this.mapBase['BG']).stopAndRemove();//			//			// In case we don't actually have the map overlay... //			try { if (this.mapOverlay) this.removeChild(this.mapOverlay); } catch (error : Error) { }//			//			// Clear mapHolder//			while (this.mapHolder.numChildren > 0) {//				this.mapHolder.removeChildAt(0);//			}//			//			// Clear arrays//			TinyFieldMap.objectArray = [];//			TinyFieldMap.objectEvents = [];//			TinyFieldMap.npcArray = []; //			this.collideThings = [];//			//			// Put everything back again//			this.mapBase 	= newMap.MAP;//			this.mapHit 	= newMap.HIT;//			if (newMap.OVERLAY) this.mapOverlay = newMap.OVERLAY;//			this.mapHolder 	= new Sprite;//			//			// Add 'em up//			this.addChild(this.mapBase);//			this.addChild(this.mapHolder);//			this.addChild(this.mapHit);//			if (newMap.OVERLAY) { this.addChild(this.mapOverlay); }//			this.addChild(this.eventSpriteHolder);//			this.addChild(this.gameMenu);//			//			// Put the menu in front//			this.setChildIndex(this.bigBlackSprite, this.numChildren - 1);//			//			// Move objects we placed in the IDE onto the main stage//			if (newMap.OBJECTS) {//				if (newMap.OBJECTS.numChildren > 0) {//					while (newMap.OBJECTS.numChildren > 0) //					{//						TinyLogManager.log('found object: ' + newMap.OBJECTS.getChildAt(0).name, this);//						//						if ((TinyFieldMap.mapName.toUpperCase() != 'MAP_CASTLE_ENTRANCE') || //							(TinyFieldMap.mapName.toUpperCase() == 'MAP_CASTLE_ENTRANCE' && TinyEventFlagData.getInstance().getFlagByName('first_battle_done').value && !TinyEventFlagData.getRecruitFlagByName('FISH').value) || //							newMap.OBJECTS.getChildByName('EVENT_DOORS')) //						{//							var newObject : DisplayObject = newMap.OBJECTS.getChildAt(0);//							newObject.x += newMap.OBJECTS.x;//							newObject.y += newMap.OBJECTS.y;//							newObject.visible = true;//							//							if (newObject.name == 'EVENT_WEIRD_THING') {//								if (TinyEventFlagData.getRecruitFlagByName('FISH').value) {//									MovieClip(newObject['blocker']).alpha = 0;//									newObject.visible = false; //									newObject.alpha = 0;//								}//							}//							//							this.mapHolder.addChild(newObject);//							TinyFieldMap.objectArray.push(newObject);//						} else {//							break;//						}//					}//				}//			}//			//			// Can we talk to any objects?//			var objectXMLData : XMLList = this.mapXMLData.child(TinyFieldMap.mapName.toUpperCase()).child('OBJECTS');//			for each (var object : XML in objectXMLData.children())//			{//				if ((TinyFieldMap.mapName.toUpperCase() != 'MAP_CASTLE_ENTRANCE') || //					(TinyFieldMap.mapName.toUpperCase() == 'MAP_CASTLE_ENTRANCE' && TinyEventFlagData.getInstance().getFlagByName('first_battle_done').value && !TinyEventFlagData.getRecruitFlagByName('FISH').value) ||//					(object.child('NAME').toString() == 'EVENT_DOORS')) //				{//					TinyLogManager.log('adding event object: ' + object.child('NAME').toString(), this);//					//					// Match to object in object array//					TinyFieldMap.objectEvents[object.child('NAME')] = object.child('EVENT');//					//					// Add to list of things to collide with//					this.collideThings.push(TinyFieldMap.getObjectByName(object.child('NAME')));//					//					// Hide object - we don't need to see it.//					if (object.child('NAME').toString() != 'EVENT_DOORS') {//						TinyFieldMap.getObjectByName(object.child('NAME')).visible = false;//					}//				} else {//					break;//				}//			}//			//			// Set up map hit layer			//			TinyFieldMap.hitLayer = newMap.HIT;//			newMap.HIT.visible = false;//			//			// Add NPCs//			var npcXMLData : XMLList = this.mapXMLData.child(TinyFieldMap.mapName.toUpperCase()).child('NPCS');//			for each (var npcData : XML in npcXMLData.children())//			{//				var newNPC : TinyFriendSprite = TinyFriendSprite.newFromXML(npcData);//				var npcPos : Point = new Point();//				var npcPosArray : Array = npcData.child('POSITION').toString().split(',');//				npcPos.x = npcPosArray[0];//				npcPos.y = npcPosArray[1];//				this.addNPCSpriteAt(newNPC, npcPos.x, npcPos.y, npcData.child('FACING').toString());//			}//			//			// Do we add a bunny?!//			if ((TinyFieldMap.mapName.toUpperCase() == 'MAP_RON_BASE' ||//				TinyFieldMap.mapName.toUpperCase() == 'MAP_ANDY_ROOM' ||//				TinyFieldMap.mapName.toUpperCase() == 'MAP_WEIRD_PLACE' ||//				TinyFieldMap.mapName.toUpperCase() == 'MAP_FISH_PRE_ANTECHAMBER' ||//				TinyFieldMap.mapName.toUpperCase() == 'MAP_FAIR_ENTRANCE')  &&//				!TinyEventFlagData.getInstance().getFlagByName('found_bunny_' + TinyFieldMap.mapName.toUpperCase()).value &&//				!TinyEventFlagData.getInstance().getFlagByName('found_all_bunnies').value && //				 TinyEventFlagData.getInstance().getFlagByName('rachel_bunnies_released').value) //			{//				var newBunny : TinyBunny = new TinyBunny;//				newBunny.event = 'bunny_talk_' + TinyFieldMap.mapName.toUpperCase();//				this.addNPCSpriteAt(newBunny, 160,136, 'LEFT');			//			}//			//			// How evil is this map?//			TinyFieldMap.evilLevel = int(this.mapXMLData.child(TinyFieldMap.mapName.toUpperCase()).child('EVIL_LEVEL').toString());//			//			// Is it really that evil? Decrease level if we have to recruit someone here or if we already have//			var recruitableChar : String = this.getCharacterForMap();//			if (recruitableChar) {//				if (TinyEventFlagData.getRecruitFlagByName(recruitableChar).value) {//					TinyFieldMap.evilLevel = 1;//				} else {//					TinyFieldMap.evilLevel = 0;//				}//			}//			//			// Get entrance positions from XML//			var entranceXML : XMLList = this.mapXMLData.child(TinyFieldMap.mapName.toUpperCase()).child('ENTER_AT');//			var playerPosition : Point = new Point();//			var posArray : Array;//			switch (entranceDir) //			{//				case 'NORTH': posArray = entranceXML.child('NORTH').toString().split(',');	break;//				case 'SOUTH': posArray = entranceXML.child('SOUTH').toString().split(',');	break;//				case 'EAST':  posArray = entranceXML.child('EAST').toString().split(',');	break;//				case 'WEST':  posArray = entranceXML.child('WEST').toString().split(',');	break;//			}//			//			// Set location			//			playerPosition.x = int(posArray[0]);//			playerPosition.y = int(posArray[1]);//			this.addPlayerSpriteAt(playerPosition.x, playerPosition.y);//			//			// Longer delay & tween for boss map//			var tweenTime : int = 15;//			var delayTime : int = 0;//			if (TinyFieldMap.mapName.toUpperCase() == 'MAP_COMPUTER_ROOM') {//				tweenTime = 24;//				delayTime = 40;//			}//			//			// Fade back in, then hand control to the player//			var player : TinyPlayer = TinyPlayer.getInstance();//			if (this.startingEventName != '') {//				TweenLite.to(this.bigBlackSprite, tweenTime, { delay:delayTime, alpha:0, useFrames:true, ease:SteppedEase.create(5) });//			} else {//				TweenLite.to(this.bigBlackSprite, tweenTime, { delay:delayTime, alpha:0, useFrames:true, ease:SteppedEase.create(5), onComplete:TinyInputManager.getInstance().setTarget, onCompleteParams:[TinyStatsEntity(player.party.party[0]).graphics] });//			}//			//			TinyFieldMap.checkWeirdThing();//			//			// TODO REMOVE//			//var saveData : TinySaveData = new TinySaveData;//			//saveData.saveAndCompressData(2);//		}				public function doRandomEncounter() : void		{//			TinyLogManager.log('========================', this);//			TinyLogManager.log('   RANDOM ENCOUNTER!', this);//			TinyLogManager.log('========================', this);//			//			// Remove control//			TinyInputManager.getInstance().setTarget(null);//			//			var totalLevels : int = 0;//			var levelCount  : int = 0;//			//			// Use average level to determine enemy set to fight//			for each (var char : TinyStatsEntity in TinyPlayer.getInstance().party.party) {//				totalLevels += char.stats.LVL;//				levelCount++;//			}//			//			// Average party level//			var avgLevel : int = Math.round(totalLevels / levelCount);//			//			// Determine which set of enemies to pull from//			var levelSet : int;//			if (avgLevel == 1 || avgLevel == 2) //				levelSet = 0;//			else if (avgLevel == 3 || avgLevel == 4)//				levelSet = 1;//			else if (avgLevel >= 5 && avgLevel <= 7) //				levelSet = 2;//			else if (avgLevel >= 8 && avgLevel <= 10)//				levelSet = 3;//			else if (avgLevel >= 11 && avgLevel <= 14)//				levelSet = 4;//			else if (avgLevel >= 15)//				levelSet = 5;//			//			var levelSetArray : Array = TinyEnemyDataList.getInstance().levelList[levelSet];//			//			// How many enemies will we fight?//			var howManyEnemies : int = 1;//			//			// For parties of two//			var rand : int = TinyMath.randomInt();//			if (TinyPlayer.getInstance().party.party.length == 2) //			{	//				// 38% chance of getting two enemies//				if (rand >= 38) {//					howManyEnemies = 2;//				}//			}//			//			// For parties of three//			if (TinyPlayer.getInstance().party.party.length == 3) //			{//				// 65% chance of getting three enemies, default to two//				if (rand >= 75) {//					//howManyEnemies = 3;//					howManyEnemies = 2;//				} else {//					howManyEnemies = 2;//				}//			}//			//			// Pick enemies//			var pickedNumbers : Array = [];//			var enemies : Array = [];//			for (var i : int = 0; i < howManyEnemies; i++) {//				var rand2 : int = TinyMath.randomInt(0, levelSetArray.length);//				while (pickedNumbers.indexOf(rand2) != -1) {//					rand2 = TinyMath.randomInt(0, levelSetArray.length - 1);//				}//				pickedNumbers.push(rand2);//				enemies.push(TinyEnemyDataList.getInstance().getEnemyByName(levelSetArray[rand2]));//			}//			//			TinyFieldMap.inBattle = true;//			//			// Start battle//			this.currentBattle = new TinyBattle(enemies, true);//			this.currentBattle.addEventListener(Event.COMPLETE, onBattleComplete);//			this.addChild(this.currentBattle);//			this.currentBattle.startBattle();		}		private function onBattleComplete(event : Event) : void 		{			TinyLogManager.log('onBattleComplete', this);			//			// Clean up//			TinyInputManager.getInstance().setTarget(null);//			this.currentBattle.removeEventListener(Event.COMPLETE, onBattleComplete);//			this.removeChild(this.currentBattle);//			this.currentBattle = null;//			//			// If we're doing Andy's quest, display gore paint message//			if (TinyEventFlagData.getInstance().getFlagByName('andy_talked_to').value && !TinyEventFlagData.getInstance().getFlagByName('andy_quest_done').value && !TinyEventFlagData.getRecruitFlagByName('ANDY').value) {//				this.addEventSequence('andy_gore_paint');//				this.startCurrentEvent();//			} else {//				// Return control to the player//				TinyInputManager.getInstance().setTarget(TinyFriendSprite(TinyStatsEntity(TinyPlayer.getInstance().party.party[0]).graphics));//			}//			//			// Restore music//			TinyAudioManager.getInstance().setSong(TinyAudioManager.getMusicByMapName(TinyFieldMap.mapName), true);		}
//		public function checkSpriteDepth(force : Boolean = false) : void//		{//			// Don't do this if we're in an event or in battle//			if (this.currentEvent && this.currentEvent.eventName && this.currentEvent.eventName != 'null') {//				if ((this.doingEvent && this.currentEvent.eventName.toUpperCase() != 'CHECK_DOOR') && !force || TinyFieldMap.inBattle || this.currentEvent.eventName.toUpperCase() == 'FINALE') { //					return;//				}//			}//			//			// Really don't do it in battle//			if (TinyFieldMap.inBattle) {//				return;//			}//				//			var playerSprite : TinyFriendSprite = TinyFriendSprite(TinyStatsEntity(TinyPlayer.getInstance().party.party[0]).graphics);//			var playerSpritePos : Point = new Point(playerSprite.x, playerSprite.y);//			playerSpritePos.x *= TinyAppSettings.SCALE_FACTOR;//			playerSpritePos.y *= TinyAppSettings.SCALE_FACTOR;//			//			//this.testOrigin1.graphics.clear();//			//this.testOrigin1.graphics.beginFill(0xFF00FF);//			//this.testOrigin1.graphics.drawCircle(playerSpritePos.x / TinyAppSettings.SCALE_FACTOR, playerSpritePos.y / TinyAppSettings.SCALE_FACTOR, 2);//			//this.testOrigin1.graphics.endFill();//			//			// Only do this if we've changed Y position//			if (this.oldY != playerSpritePos.y)	//			{//				// Depth sorting//				var sortedArray : Array = TinyFieldMap.objectArray.sort(this.sortOnY);////				// Clear map display list//				while (this.mapHolder.numChildren > 0) {//					this.mapHolder.removeChild(this.mapHolder.getChildAt(0));//				}//				//				// Put back into the list//				for (var i : uint = 0; i < sortedArray.length; i++) {//					this.mapHolder.addChild(sortedArray[i]);//				}//			}//			//			// Save old Y position	//			this.oldY = playerSpritePos.y;//			//trace(playerSprite.x, playerSprite.y);//			//			if (!force) {//				// Have we walked off the map?//				// NORTH//				if (playerSprite.y < 10 + this.northExitOffset) {//					TinyLogManager.log('NORTH', this);//					if (this.northEventName != '') {//						this.addEventSequence(this.southEventName);//						this.startCurrentEvent();//						this.northEventName = '';//						this.southEventName = '';//						this.eastEventName = '';//						this.westEventName = '';//					} else if (this.northMapName != '') {//						TinyInputManager.getInstance().setTarget(null);//						this.transitionToNewMap(TinyMapConfig.getMapFromName(this.northMapName), 'SOUTH');//					}//					return;//				}//				//				// SOUTH//				if (playerSprite.y >= 230 + this.southExitOffset) {//					TinyLogManager.log('SOUTH', this);//					if (this.southEventName != '') {//						this.addEventSequence(this.southEventName);//						this.startCurrentEvent();//						this.northEventName = '';//						this.southEventName = '';//						this.eastEventName = '';//						this.westEventName = '';//					} else if (this.southMapName != '') {//						TinyInputManager.getInstance().setTarget(null);//						this.transitionToNewMap(TinyMapConfig.getMapFromName(this.southMapName), 'NORTH');//					}//					return;//				}//				//				// EAST//				if (playerSpritePos.x >= (320 - this.eastExitOffset) * TinyAppSettings.SCALE_FACTOR) {//					TinyLogManager.log('EAST', this);//					if (this.eastEventName != '') {//						this.addEventSequence(this.eastEventName);//						this.startCurrentEvent();//						this.northEventName = '';//						this.southEventName = '';//						this.eastEventName = '';//						this.westEventName = '';//					} else if (this.eastMapName != '') {//						TinyInputManager.getInstance().setTarget(null);//						this.transitionToNewMap(TinyMapConfig.getMapFromName(this.eastMapName), 'WEST');//					}//					return;//				}//				//				// WEST//				if (playerSpritePos.x <= 10 + this.westExitOffset) {//					TinyLogManager.log('WEST', this);//					if (this.westEventName != '') {//						this.addEventSequence(this.westEventName);//						this.startCurrentEvent();//						this.northEventName = '';//						this.southEventName = '';//						this.eastEventName = '';//						this.westEventName = '';//					} else if (this.westMapName != '') {//						TinyInputManager.getInstance().setTarget(null);//						this.transitionToNewMap(TinyMapConfig.getMapFromName(this.westMapName), 'EAST');//					}//					return;//				}//			}//		}//		public function addEventSequence(eventName : String) : void//		{//			TinyLogManager.log('addEventSequence: ' + eventName, this);//			//			this.currentEvent = TinyEventSequence.newFromEventName(eventName);//			this.eventSpriteHolder.addChild(this.currentEvent);//		}//		//		public function startCurrentEvent() : void//		{//			// Special case for the check door event: it only works when you're facing the door straight on//			if (this.currentEvent && this.currentEvent.eventName) {//				if (this.currentEvent.eventName.toUpperCase() == 'CHECK_DOOR' && TinyFriendSprite(TinyStatsEntity(TinyPlayer.getInstance().fullParty.party[0]).graphics).facing != 'UP') {//					TinyLogManager.log('startCurrentEvent: NOPE! Not facing the door', this);//				} else {//					TinyLogManager.log('startCurrentEvent', this);//					TinyInputManager.getInstance().setTarget(null);//					this.currentEvent.startSequence();//					this.currentEvent.addEventListener(Event.COMPLETE, onEventSequenceComplete);//					this.doingEvent = true;//				}//			}//		}////		private function sortOnY(a : DisplayObject, b : DisplayObject) : Number//		{//			var aY : Number = a.y;//			var bY : Number = b.y;//			//			aY = a.localToGlobal(new Point(a.x, a.y)).y;//			bY = b.localToGlobal(new Point(b.x, b.y)).y;//			//			if (aY > bY) {//				return 1;		//			} else if (aY < bY) {//				return -1;//			} else {//				return 0;//			}//		}////		public static function getNPCSpriteByName(targetName : String) : TinyFriendSprite//		{//			TinyLogManager.log('getNPCSpriteByName: ' + targetName, TinyFieldMap);//			//			// Find function//			var findFunction : Function = function(item : *, index : int, array : Array) : Boolean//				{ index; array; return (TinyFriendSprite(item).charName.toUpperCase() == targetName.toUpperCase()); };//			//			// Search for character//			return TinyFieldMap.npcArray.filter(findFunction)[0];//		}//		//		public static function getObjectByName(targetName : String) : DisplayObject//		{//			//			// Find function//			var findFunction : Function = function(item : *, index : int, array : Array) : Boolean//				{ index; array; return (DisplayObject(item).name.toUpperCase() == targetName.toUpperCase()); };//			//			// Search for character//			var returnThing : DisplayObject = TinyFieldMap.objectArray.filter(findFunction)[0];////			TinyLogManager.log('getObjectByName: ' + targetName + ' = ' + returnThing, TinyFieldMap);//			return returnThing;//		}//		//		public static function checkWeirdThing() : void//		{//			TinyLogManager.log('checkWeirdThing', TinyFieldMap);//			//			// Add the weird thing//			if (TinyFieldMap.mapName.toUpperCase() == 'MAP_CASTLE_ENTRANCE' && !TinyEventFlagData.getRecruitFlagByName('FISH').value) {//				//				var tempMap : TinyCastleMap = new TinyCastleMap;//				var weirdThing : MovieClip = MovieClip(tempMap.OBJECTS.getChildByName('EVENT_WEIRD_THING'));//				weirdThing.x = tempMap.OBJECTS.x;//				weirdThing.y = tempMap.OBJECTS.y;//				if (TinyFieldMap.objectArray.indexOf(weirdThing) < 0) {//					TinyFieldMap.objectArray.push(weirdThing);//					TinyFieldMap.getInstance().mapHolder.addChild(weirdThing);//					//					// Match to object in object array//					TinyFieldMap.objectEvents['EVENT_WEIRD_THING'] = 'weird_thing';//					//					try { TinyFieldMap.collisionList.addItem(weirdThing); } catch (error : Error) { trace(error.message); } //				}//			}//		}//		//		public function showMenu(event : TinyInputEvent = null) : void//		{//			TinyLogManager.log('showMenu', this);//			//			TinyInputManager.getInstance().setTarget(this.gameMenu);//			this.gameMenu.addEventListener(TinyInputEvent.CANCEL, onMenuClose);//			this.gameMenu.show();//		}//		//		private function onEventSequenceComplete(event : Event) : void //		{//			TinyLogManager.log('onEventSequenceComplete', this);//			//			// Force trigger end sequence events//			if (this.currentEvent.eventName.toUpperCase() == 'FINALE') {//				this.endGame = true;//			}////			// Clean up//			this.eventSpriteHolder.removeChild(this.currentEvent);//			this.currentEvent.removeEventListener(Event.COMPLETE, onEventSequenceComplete);//			this.currentEvent = null;//			this.doingEvent = false;//			//			// Trigger end events if we're at that point			//			if (this.endGame) {//				var nextEventName : String = this.endSequence.shift();//				if (nextEventName == '' || !nextEventName) //				{//					var whiteSolid : Sprite = new Sprite;//					whiteSolid.graphics.beginFill(0xFFFFFF);//					whiteSolid.graphics.drawRect(0, 0, 320, 240);//					whiteSolid.graphics.endFill();//					this.addChild(whiteSolid);//					TinyInputManager.getInstance().setTarget(null);//					var endCards : TinyEnding = new TinyEnding;//					this.addChild(endCards);//					endCards.show();//					// Clean up//				} else {//					this.addEventSequence(nextEventName);//					this.startCurrentEvent();//					TinyInputManager.getInstance().setTarget(null);//				}//			}//			//			// Return control to the player//			TinyInputManager.getInstance().setTarget(TinyFriendSprite(TinyStatsEntity(TinyPlayer.getInstance().party.party[0]).graphics));//		}//		private function onMenuClose(event : TinyInputEvent) : void //		{//			TinyLogManager.log('onMenuClose', this);//			//			// Clean up//			this.gameMenu.removeEventListener(TinyInputEvent.CANCEL, onMenuClose);//			this.gameMenu.hide();//		//			// Return control to the player sprite//			TinyInputManager.getInstance().setTarget(TinyFriendSprite(TinyStatsEntity(TinyPlayer.getInstance().party.party[0]).graphics));//		}//		//		private function getCharacterForMap() : String//		{//			TinyLogManager.log('getCharacterForMap', this);//			//			var returnString : String;//			switch (TinyFieldMap.mapName.toUpperCase()) //			{//				case 'MAP_ASA_RIVER'://					returnString = 'ASA';		break;	//				case 'MAP_ANDY_ROOM'://					returnString = 'ANDY';		break;//				case 'MAP_MEGAN_ROOM'://					returnString = 'MEGAN';		break;		//				case 'MAP_FAIR'://					returnString = 'JASON';		break;		//				case 'MAP_FISH_CHAMBER'://					returnString = 'FISH';		break;		//				case 'MAP_RACHEL_FARM'://					returnString = 'RACHEL';	break;		//				case 'MAP_RALPH_RED_ROOM'://					returnString = 'RALPH';		break;//				case 'MAP_RON_BASE'://					returnString = 'RON';		break;
//			}//			return returnString;//		}////		// Singleton//		public static function getInstance() : TinyFieldMap//		{//			return instance;//		}	}}