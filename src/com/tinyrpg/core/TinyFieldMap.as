package com.tinyrpg.core {	import com.greensock.TweenLite;	import com.coreyoneil.collision.CollisionGroup;		import com.tinyrpg.core.TinyMon;	import com.tinyrpg.core.TinyPlayer;	import com.tinyrpg.data.TinyCollisionData;	import com.tinyrpg.data.TinyWildEncounterData;	import com.tinyrpg.data.TinyFieldMapObject;	import com.tinyrpg.data.TinyFieldMapObjectNPC;	import com.tinyrpg.data.TinyFieldMapObjectTrigger;	import com.tinyrpg.display.TinyMapMovieClip;	import com.tinyrpg.events.TinyFieldMapEvent;	import com.tinyrpg.lookup.TinyMapLookup;	import com.tinyrpg.managers.TinyMapManager;	import com.tinyrpg.utils.TinyLogManager;	import com.tinyrpg.utils.TinyMath;	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.DisplayObject;	import flash.display.MovieClip;	import flash.display.Sprite;	import flash.events.Event;	/**	 * @author jeremyabel	 */	public class TinyFieldMap extends Sprite 	{		public static const COLLISION_TYPE_WALLS	: String = 'WALLS';		public static const COLLISION_TYPE_OBJECTS	: String = 'OBJECTS';		public static const COLLISION_TYPE_GRASS 	: String = 'GRASS';		public static const COLLISION_TYPE_JUMPS	: String = 'JUMPS';		public static const COLLISION_TYPE_DISABLE	: String = 'DISABLE'; 				public var mapName						: String;		public var mapUserObjects				: Sprite;		public var startingEventName			: String;		public var encounterRate				: int;		public var encounterData				: TinyWildEncounterData;		public var usedRepel					: Boolean = false;						public var eventXML 					: XML;		private var mapMovieClip				: TinyMapMovieClip;		private var currentEventSequence		: TinyEventSequence;		private var mapObjects					: MovieClip;		private var mapBase						: MovieClip;		private var mapHit						: MovieClip;		private var mapMiscCollisionContainer 	: Sprite;		private var collisionWalls 				: CollisionGroup;		private var collisionGrass				: CollisionGroup;		private var collisionJumps				: CollisionGroup;				private var collisionObjects			: CollisionGroup;		private var collisionDisable			: CollisionGroup;		private var npcReadyCount				: uint = 0;		private var npcArray					: Array = [];				public function get gameoverMapName() : String { return this.mapMovieClip.gameoverMapName; }		public function TinyFieldMap( mapName : String ) : void		{			this.mapName = mapName;			this.encounterRate = TinyMapLookup.getEncounterRateForName( this.mapName );			this.encounterData = TinyMapLookup.getEncounterDataForName( this.mapName );			this.npcReadyCount = 0;						this.mapMovieClip = TinyMapLookup.getMapFromName( this.mapName );			this.mapBase = this.mapMovieClip.map;			this.mapHit = this.mapMovieClip.hit;			this.mapHit.visible = false;						// Draw map border boundaries on the map collision layer			this.mapHit.graphics.lineStyle( 16, 0xFF00FF );			this.mapHit.graphics.drawRect( -8, -8, this.mapBase.width + 16, this.mapBase.height + 16 );			this.mapHit.graphics.endFill();						this.mapObjects = this.mapMovieClip.objects;			this.mapUserObjects = new Sprite();			this.mapMiscCollisionContainer = new Sprite();			this.mapMiscCollisionContainer.visible = false;						// Collision groups			this.collisionWalls = new CollisionGroup( this.mapHit );			this.collisionGrass = new CollisionGroup();			this.collisionJumps = new CollisionGroup();			this.collisionObjects = new CollisionGroup();			this.collisionDisable = new CollisionGroup();						for ( var i : uint = 0; i < this.mapObjects.numChildren; i++ )			{				var mapObject : TinyFieldMapObject = ( this.mapObjects.getChildAt( i ) as TinyFieldMapObject );								// NPC objects are handled differently				if ( mapObject is TinyFieldMapObjectNPC )				{					// Wait for NPC data to be ready before adding them to the NPC array and collision groups					// If this is done too early, incorrect NPC names will be stored in the array and the 					// getNPCObjectByName() function will fail. 					mapObject.addEventListener( TinyFieldMapEvent.DATA_READY, this.onNPCDataReady );					this.npcReadyCount++;				}				else 				{					// Add each map object to the objects collision group					this.addToCollisionGroup( mapObject.hitbox, COLLISION_TYPE_OBJECTS );				}			}						// Add optional map layers to their cooresponding collision groups if they exist			if ( this.mapMovieClip.hasGrass ) { this.mapMiscCollisionContainer.addChild( this.mapMovieClip.grass ); this.addToCollisionGroup( this.mapMovieClip.grass, COLLISION_TYPE_GRASS ); }			if ( this.mapMovieClip.hasJumpU ) { this.mapMiscCollisionContainer.addChild( this.mapMovieClip.jumpU ); this.addToCollisionGroup( this.mapMovieClip.jumpU, COLLISION_TYPE_JUMPS ); }			if ( this.mapMovieClip.hasJumpD ) { this.mapMiscCollisionContainer.addChild( this.mapMovieClip.jumpD ); this.addToCollisionGroup( this.mapMovieClip.jumpD, COLLISION_TYPE_JUMPS ); }			if ( this.mapMovieClip.hasJumpL ) { this.mapMiscCollisionContainer.addChild( this.mapMovieClip.jumpL ); this.addToCollisionGroup( this.mapMovieClip.jumpL, COLLISION_TYPE_JUMPS ); }			if ( this.mapMovieClip.hasJumpR ) { this.mapMiscCollisionContainer.addChild( this.mapMovieClip.jumpR ); this.addToCollisionGroup( this.mapMovieClip.jumpR, COLLISION_TYPE_JUMPS ); }			if ( this.mapMovieClip.hasDisableU ) { this.mapMiscCollisionContainer.addChild( this.mapMovieClip.disableU ); this.addToCollisionGroup( this.mapMovieClip.disableU, COLLISION_TYPE_DISABLE ); }						// Get event sequence XML data			this.eventXML = TinyMapLookup.getMapEventXMLFromName( mapName );						// Add 'em up			this.addChild( this.mapBase );			this.addChild( this.mapHit );			this.addChild( this.mapObjects );			this.addChild( this.mapMiscCollisionContainer );			this.addChild( this.mapUserObjects );						// Dispatch the map's ready event after one frame if there are no NPCs to wait for			if ( this.npcReadyCount == 0 ) 			{				TweenLite.delayedCall( 1, this.dispatchEvent, [ new TinyFieldMapEvent( TinyFieldMapEvent.DATA_READY ) ], true );			}		}				private function onNPCDataReady( event : TinyFieldMapEvent ) : void		{			var npcObject : TinyFieldMapObjectNPC = event.param as TinyFieldMapObjectNPC; 						TinyLogManager.log( 'adding NPC: ' + npcObject.npcName, this );						// Cleanup			npcObject.removeEventListener( TinyFieldMapEvent.DATA_READY, this.onNPCDataReady );			// Add to NPC array			this.npcArray.push( npcObject );						// Add the NPC's hitbox to the objects and walls collision groups			this.addToCollisionGroup( npcObject.hitbox, COLLISION_TYPE_OBJECTS );			this.addToCollisionGroup( npcObject.hitbox, COLLISION_TYPE_WALLS );						// Dispatch the map's ready event when all NPCs are accounted for 			if ( this.npcArray.length == this.npcReadyCount ) 			{				this.dispatchEvent( new TinyFieldMapEvent( TinyFieldMapEvent.DATA_READY ) );				}		}				public function addToCollisionGroup( object : DisplayObject, type : String = COLLISION_TYPE_WALLS ) : void		{			switch ( type ) 			{				default:				case COLLISION_TYPE_WALLS:		this.collisionWalls.addItem( object ); break;				case COLLISION_TYPE_GRASS:		this.collisionGrass.addItem( object ); break;				case COLLISION_TYPE_JUMPS:		this.collisionJumps.addItem( object ); break;				case COLLISION_TYPE_OBJECTS:	this.collisionObjects.addItem( object ); break;				case COLLISION_TYPE_DISABLE:	this.collisionDisable.addItem( object ); break;			}		}				public function removeFromCollisionGroup( object : DisplayObject, type : String = COLLISION_TYPE_WALLS ) : void		{			switch ( type ) 			{				default:				case COLLISION_TYPE_WALLS:		this.collisionWalls.removeItem( object ); break;				case COLLISION_TYPE_GRASS:		this.collisionGrass.removeItem( object ); break;				case COLLISION_TYPE_JUMPS:		this.collisionJumps.removeItem( object ); break;				case COLLISION_TYPE_OBJECTS:	this.collisionObjects.removeItem( object ); break;				case COLLISION_TYPE_DISABLE:	this.collisionDisable.removeItem( object ); break;			}		}				public function checkWallCollision( object : DisplayObject ) : TinyCollisionData		{				return this.collisionWalls.checkCollision( object );		}				public function checkGrassCollision( object : DisplayObject ) : TinyCollisionData 		{			return this.collisionGrass.checkCollision( object );		}				public function checkJumpCollision( object : DisplayObject ) : TinyCollisionData 		{			return this.collisionJumps.checkCollision( object );		}				public function checkObjectCollision( object : DisplayObject ) : TinyCollisionData		{				return this.collisionObjects.checkCollision( object );		}				public function checkDisableCollision( object : DisplayObject ) : TinyCollisionData 		{			return this.collisionDisable.checkCollision( object );		}				public function getMapObjectByName( objectName : String ) : DisplayObject		{			return this.mapObjects.getChildByName( objectName );		}						public function tryWildEncounter() : TinyMon		{			if ( TinyPlayer.getInstance().usedRepel ) return null;						if ( TinyMath.randomInt( 0, 255 ) < this.encounterRate )			{				return this.encounterData.getEncounterMon();						}						return null;		}		public function startEventByName( eventName : String ) : void		{			TinyLogManager.log( 'startEventByName: ' + eventName, this );						// Create the new event sequence			this.currentEventSequence = TinyEventSequence.newFromEventName( this.eventXML, eventName );						// Add the sequence to the map manager's event container sprite			TinyMapManager.getInstance().mapEventContainer.addChild( this.currentEventSequence );						// Start the event sequence			this.currentEventSequence.addEventListener( Event.COMPLETE, this.onEventSequenceComplete );			this.currentEventSequence.startSequence();		}		private function onEventSequenceComplete( event : Event ) : void 		{			TinyLogManager.log( 'onEventSequenceComplete', this );						// Remove the sequence from the map manager's event container sprite			TinyMapManager.getInstance().mapEventContainer.removeChild( this.currentEventSequence );						// Get the restorControl and eventName values from the event sequence before it is cleared.			// These values will be used during warp event commands in the MapManager. 			var restoreControl : Boolean = this.currentEventSequence.restoreControl;			var eventName : String = this.currentEventSequence.eventName;						// Clean up			this.currentEventSequence.removeEventListener( Event.COMPLETE, this.onEventSequenceComplete );			this.currentEventSequence = null;						// Alert the map manager that the event is complete			this.dispatchEvent( new TinyFieldMapEvent( TinyFieldMapEvent.EVENT_COMPLETE, {				eventName: eventName,				restoreControl: restoreControl			}));		}		public function getNPCObjectByName( targetName : String ) : TinyFieldMapObjectNPC		{			TinyLogManager.log( 'getNPCObjectByName: ' + targetName, this );						var findByNameFunction : Function = function( item : *, index : int, array : Array ) : Boolean			{ 					// Use mandatory variables to prevent compiler warnings				index;				array; 								return ( item as TinyFieldMapObjectNPC ).npcName.toUpperCase() == targetName.toUpperCase(); 			};						// Search for an npc with a matching name			return this.npcArray.filter( findByNameFunction )[ 0 ];		}				public function addNPCObject( npcObject : TinyFieldMapObjectNPC ) : void		{			TinyLogManager.log( 'addNPCObject: ' + npcObject.npcName, this );				// Add to collision groups				this.addToCollisionGroup( npcObject.hitbox, COLLISION_TYPE_OBJECTS );			this.addToCollisionGroup( npcObject.hitbox, COLLISION_TYPE_WALLS );						// Add 'em up						this.mapObjects.addChild( npcObject );			this.npcArray.push( npcObject );		}				public function removeNPCByName( npcName : String ) : void		{			TinyLogManager.log( 'removeNPCByName: ' + npcName, this );						// Find the NPC with the given name			var npcToRemove : TinyFieldMapObjectNPC = this.getNPCObjectByName( npcName );						// Remove from collision lists			this.removeFromCollisionGroup( npcToRemove.hitbox, COLLISION_TYPE_OBJECTS );			this.removeFromCollisionGroup( npcToRemove.hitbox, COLLISION_TYPE_WALLS );						// Remove from display list				this.mapObjects.removeChild( npcToRemove );						// Remove from the NPC array			this.npcArray.splice( this.npcArray.indexOf( npcToRemove ), 1 );		}				public function removeTriggerByName( triggerName : String ) : void		{			TinyLogManager.log( 'removeTriggerByName: ' + triggerName, this );						// Find the trigger with the given name			var triggerToRemove : TinyFieldMapObjectTrigger = this.mapObjects.getChildByName( triggerName ) as TinyFieldMapObjectTrigger;						// Remove from collision list			this.removeFromCollisionGroup( triggerToRemove.hitbox, COLLISION_TYPE_OBJECTS );						// Remove from display list				this.mapObjects.removeChild( triggerToRemove );		}	}}