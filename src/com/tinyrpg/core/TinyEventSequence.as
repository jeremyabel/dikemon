package com.tinyrpg.core {	import com.greensock.TweenLite;		import com.tinyrpg.battle.TinyBattle;	import com.tinyrpg.data.TinyEventFlag;	import com.tinyrpg.data.TinyItemDataList;	import com.tinyrpg.events.TinySequenceEvent;	import com.tinyrpg.lookup.TinyEventFlagLookup;	import com.tinyrpg.managers.TinyAudioManager;	import com.tinyrpg.managers.TinyInputManager;	import com.tinyrpg.managers.TinyMapManager;	import com.tinyrpg.sequence.TinyAddNPCCommand;	import com.tinyrpg.sequence.TinyAnimCommand;	import com.tinyrpg.sequence.TinyChooseStarterCommand;	import com.tinyrpg.sequence.TinyConditionalCommand;	import com.tinyrpg.sequence.TinyEventItem;	import com.tinyrpg.sequence.TinyEmoteCommand;	import com.tinyrpg.sequence.TinyItemCommand;	import com.tinyrpg.sequence.TinyMusicCommand;	import com.tinyrpg.sequence.TinySetPosCommand;	import com.tinyrpg.sequence.TinySetFacingCommand;	import com.tinyrpg.sequence.TinyWalkCommand;	import com.tinyrpg.sequence.TinyWarpCommand;	import com.tinyrpg.ui.TinyDialogBox;	import com.tinyrpg.utils.TinyLogManager;	import flash.display.Sprite;	import flash.events.Event;	import flash.media.Sound;	/**	 * @author jeremyabel	 */	public class TinyEventSequence extends Sprite	{		private var eventSequence 		: Array = [];		private var currentBattle   	: TinyBattle;		private var currentDialog   	: TinyDialogBox;		private var currentWalkCommand	: TinyWalkCommand;		private var currentAnimCommand	: TinyAnimCommand;				public var restoreControl		: Boolean = true;		public var eventXMLData  		: XML;		public var eventDepth	 		: int = 0;
		public var eventName	 		: String;
		public function TinyEventSequence() : void { }				public static function newFromEventName( sourceXML : XML, eventName : String ) : TinyEventSequence		{			var newEventSequence : TinyEventSequence = new TinyEventSequence();			TinyLogManager.log( 'newFromEventName: ' + eventName, newEventSequence );						newEventSequence.eventName = eventName;			newEventSequence.eventXMLData = sourceXML;						// Find in XML			var eventList : XMLList = sourceXML.child( 'EVENT_' + eventName ).child( 'SEQUENCE' );						// Check for a restoreControl = "false" attribute and clear the flag which allows the MapManager to			// return control to the player after the event sequence is complete.			if ( eventList.attribute( 'restoreControl' ).toString().toUpperCase() == 'FALSE' )			{				newEventSequence.restoreControl = false; 			}			for each ( var eventXML : XML in eventList.children() )			{				var eventType : String = eventXML.name();								switch ( eventType )				{					case TinyEventItem.BATTLE:			newEventSequence.addBattle( eventXML ); break;					case TinyEventItem.CONDITIONAL:		newEventSequence.addCondition( eventXML ); break;					case TinyEventItem.DIALOG:			newEventSequence.addDialog( eventXML ); break;					case TinyEventItem.ADD_NPC:			newEventSequence.addNPC( eventXML ); break;					case TinyEventItem.REMOVE_NPC:		newEventSequence.removeNPC( eventXML ); break;					case TinyEventItem.SHOW_EMOTE:		newEventSequence.addShowEmote( eventXML ); break;					case TinyEventItem.HIDE_EMOTE:		newEventSequence.addHideEmote( eventXML ); break;					case TinyEventItem.SET_FACING:		newEventSequence.addSetFacing( eventXML ); break;					case TinyEventItem.GIVE_ITEM:		newEventSequence.addGiveItem( eventXML ); break;					case TinyEventItem.TAKE_ITEM:		newEventSequence.addTakeItem( eventXML ); break;					case TinyEventItem.GIVE_MONEY:		newEventSequence.addGiveMoney( eventXML ); break;					case TinyEventItem.TAKE_MONEY:		newEventSequence.addTakeMoney( eventXML ); break;					case TinyEventItem.PLAY_ANIM:		newEventSequence.addAnimation( eventXML ); break;					case TinyEventItem.PLAY_SOUND:		newEventSequence.addSound( eventXML ); break;					case TinyEventItem.PLAY_MUSIC:		newEventSequence.addMusic( eventXML ); break;					case TinyEventItem.SET_FLAG:		newEventSequence.addFlagSet( eventXML ); break;					case TinyEventItem.CLEAR_FLAG:		newEventSequence.addFlagClear( eventXML ); break;					case TinyEventItem.DELAY:			newEventSequence.addPause( eventXML ); break;					case TinyEventItem.HEAL_ALL:		newEventSequence.addHealAll(); break;					case TinyEventItem.WALK:			newEventSequence.addWalk( eventXML ); break;					case TinyEventItem.WARP:			newEventSequence.addWarp( eventXML ); break;					case TinyEventItem.REMOVE_TRIGGER:	newEventSequence.addRemoveTrigger( eventXML ); break;					case TinyEventItem.CHOOSE_STARTER:	newEventSequence.addChooseStarter( eventXML ); break;					case TinyEventItem.SET_POSITION:	newEventSequence.addSetPosition( eventXML ); break;					case TinyEventItem.SUB_SEQUENCE:	newEventSequence.addSubSequence( eventXML ); break;					default: case TinyEventItem.END:	newEventSequence.addEnd(); break;				}			}						return newEventSequence;		}				public static function newFromXML( xmlData : XML, sourceXML : XML, eventName : String ) : TinyEventSequence		{			var newEventSequence : TinyEventSequence = new TinyEventSequence();						newEventSequence.eventName = eventName;			newEventSequence.eventXMLData = sourceXML;						// Check for a restoreControl = "false" attribute and clear the flag which allows the MapManager to			// return control to the player after the event sequence is complete.			if ( xmlData.attribute( 'restoreControl' ).toString().toUpperCase() == 'FALSE' )			{				newEventSequence.restoreControl = false; 			}						// Add events to the sequence			for each ( var eventXML : XML in xmlData.child( 'SEQUENCE' ).children() )			{				var eventType : String = eventXML.name();								switch ( eventType )				{					case TinyEventItem.BATTLE:			newEventSequence.addBattle( eventXML ); break;					case TinyEventItem.CONDITIONAL:		newEventSequence.addCondition( eventXML ); break;					case TinyEventItem.DIALOG:			newEventSequence.addDialog( eventXML ); break;					case TinyEventItem.ADD_NPC:			newEventSequence.addNPC( eventXML ); break;					case TinyEventItem.REMOVE_NPC:		newEventSequence.removeNPC( eventXML ); break;					case TinyEventItem.SHOW_EMOTE:		newEventSequence.addShowEmote( eventXML ); break;					case TinyEventItem.HIDE_EMOTE:		newEventSequence.addHideEmote( eventXML ); break;					case TinyEventItem.SET_FACING:		newEventSequence.addSetFacing( eventXML ); break;					case TinyEventItem.GIVE_ITEM:		newEventSequence.addGiveItem( eventXML ); break;					case TinyEventItem.TAKE_ITEM:		newEventSequence.addTakeItem( eventXML ); break;					case TinyEventItem.GIVE_MONEY:		newEventSequence.addGiveMoney( eventXML ); break;					case TinyEventItem.TAKE_MONEY:		newEventSequence.addTakeMoney( eventXML ); break;					case TinyEventItem.PLAY_ANIM:		newEventSequence.addAnimation( eventXML ); break;					case TinyEventItem.PLAY_SOUND:		newEventSequence.addSound( eventXML ); break;					case TinyEventItem.PLAY_MUSIC:		newEventSequence.addMusic( eventXML ); break;					case TinyEventItem.SET_FLAG:		newEventSequence.addFlagSet( eventXML ); break;					case TinyEventItem.CLEAR_FLAG:		newEventSequence.addFlagClear( eventXML ); break;					case TinyEventItem.DELAY:			newEventSequence.addPause( eventXML ); break;					case TinyEventItem.HEAL_ALL:		newEventSequence.addHealAll(); break;					case TinyEventItem.WALK:			newEventSequence.addWalk( eventXML ); break;					case TinyEventItem.WARP:			newEventSequence.addWarp( eventXML ); break;					case TinyEventItem.REMOVE_TRIGGER:	newEventSequence.addRemoveTrigger( eventXML ); break;					case TinyEventItem.CHOOSE_STARTER:	newEventSequence.addChooseStarter( eventXML ); break;					case TinyEventItem.SET_POSITION:	newEventSequence.addSetPosition( eventXML ); break;					case TinyEventItem.SUB_SEQUENCE:	newEventSequence.addSubSequence( eventXML ); break;					default: case TinyEventItem.END:	newEventSequence.addEnd(); break;				}			}			return newEventSequence;		}		public function startSequence() : void		{			TinyLogManager.log( 'startSequence with depth ' + this.eventDepth + ': ' + this.eventName, this );							this.addEventListener( TinySequenceEvent.SEQUENCE_END, onSequenceEnd );			this.doNextCommand();		}				///////////////////////////////////////////////////////////////////////////////////////////////		// ADDING EVENTS TO THE SEQUENCE		///////////////////////////////////////////////////////////////////////////////////////////////				private function addBattle( xmlData : XML ) : void		{			// TODO: Implement for TinyBattleMon		}		private function addCondition( xmlData : XML ) : void		{			TinyLogManager.log( 'addCondition', this );						// Make new conditional command			var newConditionalCommand : TinyConditionalCommand = TinyConditionalCommand.newFromXML( xmlData );			var newEventItem : TinyEventItem = new TinyEventItem( TinyEventItem.CONDITIONAL, newConditionalCommand );						// Add to sequence			this.eventSequence.push( newEventItem );		}		private function addDialog( xmlData : XML ) : void		{			TinyLogManager.log( 'addDialog', this );								// Make new dialog			var newDialog : TinyDialogBox = TinyDialogBox.newFromXML( xmlData );			var newEventItem : TinyEventItem = new TinyEventItem( TinyEventItem.DIALOG, newDialog );						// Add to sequence			this.eventSequence.push( newEventItem );		}				private function addNPC( xmlData : XML ) : void		{			TinyLogManager.log( 'addNPC', this );						// Make new add NPC command						var newNPCCommand : TinyAddNPCCommand = TinyAddNPCCommand.newFromXML( xmlData );			var newEventItem : TinyEventItem = new TinyEventItem( TinyEventItem.ADD_NPC, newNPCCommand );						// Add to sequence			this.eventSequence.push( newEventItem );		}				private function removeNPC( xmlData : XML ) : void		{			TinyLogManager.log( 'removeNPC', this );						// Make new remove NPC event			var newEventItem : TinyEventItem = new TinyEventItem( TinyEventItem.REMOVE_NPC, xmlData.toString() );						// Add to sequence			this.eventSequence.push( newEventItem );		}				private function addShowEmote( xmlData : XML ) : void		{			TinyLogManager.log( 'addShowEmote', this );						// Make new emote command						var newEmoteCommand : TinyEmoteCommand = TinyEmoteCommand.newFromXML( xmlData, true );			var newEventItem : TinyEventItem = new TinyEventItem( TinyEventItem.SHOW_EMOTE, newEmoteCommand );						// Add to sequence			this.eventSequence.push( newEventItem );		}				private function addHideEmote( xmlData : XML ) : void		{			TinyLogManager.log( 'addHideEmote', this );						// Make new emote command						var newEmoteCommand : TinyEmoteCommand = TinyEmoteCommand.newFromXML( xmlData, false );			var newEventItem : TinyEventItem = new TinyEventItem( TinyEventItem.HIDE_EMOTE, newEmoteCommand );						// Add to sequence			this.eventSequence.push( newEventItem );		}				private function addSetFacing( xmlData : XML ) : void		{			TinyLogManager.log( 'addSetFacing', this );							// Make new facing command			var newFacingCommand : TinySetFacingCommand = TinySetFacingCommand.newFromXML( xmlData );			var newEventItem : TinyEventItem = new TinyEventItem( TinyEventItem.SET_FACING, newFacingCommand );						// Add to sequence			this.eventSequence.push( newEventItem );		}			private function addSubSequence( xmlData : XML ) : void		{			TinyLogManager.log( 'addSubSequence', this );						// Make new sequence			var newSequence : TinyEventSequence = TinyEventSequence.newFromEventName( this.eventXMLData, xmlData.toString() );			var newEventItem : TinyEventItem = new TinyEventItem( TinyEventItem.SUB_SEQUENCE, newSequence );						// Add to sequence			this.eventSequence.push( newEventItem );		}				private function addGiveItem( xmlData : XML ) : void		{			TinyLogManager.log( 'addGiveItem', this );						// Get item from XML			var item : TinyItem = TinyItemDataList.getInstance().getItemByName( xmlData.toString() );						// Make new item command			var newItemCommand : TinyItemCommand = new TinyItemCommand( false, item );			var newEventItem : TinyEventItem = new TinyEventItem( TinyEventItem.GIVE_ITEM, newItemCommand );						// Add to sequence			this.eventSequence.push( newEventItem );		}				private function addTakeItem( xmlData : XML ) : void		{			TinyLogManager.log( 'addTakeItem', this );						// Get item from XML			var item : TinyItem = TinyItemDataList.getInstance().getItemByName( xmlData.toString() );						// Make new item command			var newItemCommand : TinyItemCommand = new TinyItemCommand( true, item );			var newEventItem : TinyEventItem = new TinyEventItem( TinyEventItem.TAKE_ITEM, newItemCommand );						// Add to sequence			this.eventSequence.push( newEventItem );		}				private function addGiveMoney( xmlData : XML ) : void		{			TinyLogManager.log( 'addGiveMoney', this );						// Get params from XML			var amount : int = int( xmlData.toString() );						// Make new item command			var newItemCommand : TinyItemCommand = new TinyItemCommand( false, null, amount );			var newEventItem : TinyEventItem = new TinyEventItem( TinyEventItem.GIVE_MONEY, newItemCommand );						// Add to sequence			this.eventSequence.push( newEventItem );		}		private function addTakeMoney( xmlData : XML ) : void		{			TinyLogManager.log( 'addTakeMoney', this );						// Get params from XML			var amount : int = int( xmlData.toString() );						// Make new item command			var newItemCommand : TinyItemCommand = new TinyItemCommand( true, null, amount );			var newEventItem : TinyEventItem = new TinyEventItem( TinyEventItem.TAKE_MONEY, newItemCommand );						// Add to sequence			this.eventSequence.push( newEventItem );			}		private function addAnimation( xmlData : XML ) : void		{			TinyLogManager.log( 'addAnimation', this );							// Make new animation command			var newAnimCommand : TinyAnimCommand = TinyAnimCommand.newFromXML( xmlData );			var newEventItem : TinyEventItem = new TinyEventItem( TinyEventItem.PLAY_ANIM, newAnimCommand );						// Add to sequence			this.eventSequence.push( newEventItem );		}				private function addSound( xmlData : XML ) : void		{			TinyLogManager.log( 'addSound', this );						// Make new sound			var newSound : Sound = TinyAudioManager.getSoundByName( xmlData.toString() );			var newEventItem : TinyEventItem = new TinyEventItem( TinyEventItem.PLAY_SOUND, newSound );						// Add to sequence			this.eventSequence.push( newEventItem );		}				private function addMusic( xmlData : XML ) : void		{			TinyLogManager.log( 'addMusic', this );						// Make new event item			var newMusicCommand : TinyMusicCommand = TinyMusicCommand.newFromXML( xmlData );			var newEventItem : TinyEventItem = new TinyEventItem( TinyEventItem.PLAY_MUSIC, newMusicCommand );						// Add to sequence			this.eventSequence.push( newEventItem );		}			private function addFlagSet( xmlData : XML ) : void		{			// Get flag from xml			var newFlag : TinyEventFlag = TinyEventFlagLookup.getInstance().getFlagByName( xmlData );			var newEventItem : TinyEventItem = new TinyEventItem( TinyEventItem.SET_FLAG, newFlag );			TinyLogManager.log( 'addFlagSet: ' + newFlag.name, this );						// Add to sequence			this.eventSequence.push( newEventItem );		}				private function addFlagClear( xmlData : XML ) : void		{			// Get flag from xml			var newFlag : TinyEventFlag = TinyEventFlagLookup.getInstance().getFlagByName( xmlData );			var newEventItem : TinyEventItem = new TinyEventItem( TinyEventItem.CLEAR_FLAG, newFlag );			TinyLogManager.log( 'addFlagClear: ' + newFlag.name, this );						// Add to sequence			this.eventSequence.push( newEventItem );		}				private function addPause( xmlData : XML ) : void		{			// Make new event item			var pauseTime : int = int( xmlData.toString() );			var newEventItem : TinyEventItem = new TinyEventItem( TinyEventItem.DELAY, pauseTime );						TinyLogManager.log( 'addPause: ' + pauseTime + ' frames', this ); 						// Add to sequence			this.eventSequence.push( newEventItem );		}				private function addHealAll() : void		{			TinyLogManager.log( 'addHealAll', this );						var newEventItem : TinyEventItem = new TinyEventItem( TinyEventItem.HEAL_ALL, null );						// Add to sequence			this.eventSequence.push( newEventItem );		}				private function addWalk( xmlData : XML ) : void		{			TinyLogManager.log( 'addWalk', this );						// Make new walk command			var newWalkCommand : TinyWalkCommand = TinyWalkCommand.newFromXML( xmlData );			var newEventItem : TinyEventItem = new TinyEventItem( TinyEventItem.WALK, newWalkCommand );						// Add to sequence			this.eventSequence.push( newEventItem );		}				private function addWarp( xmlData : XML )  : void		{			TinyLogManager.log( 'addWarp', this );						// Make new warp command			var newWarpCommand : TinyWarpCommand = TinyWarpCommand.newFromXML( xmlData );			var newEventItem : TinyEventItem = new TinyEventItem( TinyEventItem.WARP, newWarpCommand );						// Add to sequence			this.eventSequence.push( newEventItem );		}				private function addRemoveTrigger( xmlData : XML ) : void		{			TinyLogManager.log( 'removeTrigger: ' + xmlData.toString(), this );						var newEventItem : TinyEventItem = new TinyEventItem( TinyEventItem.REMOVE_TRIGGER, xmlData.toString() );						// Add to sequence			this.eventSequence.push( newEventItem );		}				private function addChooseStarter( xmlData : XML ) : void		{			TinyLogManager.log( 'addChooseStarter', this );						// Make new "choose starter" command			var newChooseStarterCommand : TinyChooseStarterCommand = TinyChooseStarterCommand.newFromXML( xmlData );			var newEventItem : TinyEventItem = new TinyEventItem( TinyEventItem.CHOOSE_STARTER, newChooseStarterCommand );						// Add to sequence			this.eventSequence.push( newEventItem );		}				private function addSetPosition( xmlData : XML ) : void		{			TinyLogManager.log( 'addSetPosition', this );						// Make new command			var newCommand : TinySetPosCommand = TinySetPosCommand.newFromXML( xmlData );			var newEventItem : TinyEventItem = new TinyEventItem( TinyEventItem.SET_POSITION, newCommand );						// Add to sequence			this.eventSequence.push( newEventItem );		}		private function addEnd() : void		{			TinyLogManager.log( 'addEnd', this );						// Make new event item			var newEventItem : TinyEventItem = new TinyEventItem( TinyEventItem.END, null );						// Add to sequence			this.eventSequence.push( newEventItem );		}				private function doNextCommand() : void		{			this.logWithDepth( 'doNextCommand' ); 						var nextEvent : TinyEventItem = this.eventSequence.shift();						if ( !nextEvent )			{				this.onSequenceEnd();				return;			}							switch ( nextEvent.type )			{				case TinyEventItem.BATTLE:				this.doBattle( nextEvent.thingToDo ); break;				case TinyEventItem.CONDITIONAL:			this.doCondition( nextEvent.thingToDo ); break;				case TinyEventItem.DIALOG:				this.doDialog( TinyDialogBox( nextEvent.thingToDo ) ); break;				case TinyEventItem.ADD_NPC:				this.doAddNPC( nextEvent.thingToDo ); break;				case TinyEventItem.REMOVE_NPC:			this.doRemoveNPC( nextEvent.thingToDo ); break;				case TinyEventItem.SHOW_EMOTE:			this.doShowEmote( nextEvent.thingToDo ); break;				case TinyEventItem.HIDE_EMOTE:			this.doHideEmote( nextEvent.thingToDo ); break;				case TinyEventItem.SET_FACING:			this.doSetFacing( nextEvent.thingToDo ); break;				case TinyEventItem.SUB_SEQUENCE:		this.doSubSequence( nextEvent.thingToDo ); break;				case TinyEventItem.GIVE_ITEM:			this.doItemCommand( nextEvent.thingToDo ); break;				case TinyEventItem.TAKE_ITEM:			this.doItemCommand( nextEvent.thingToDo ); break;				case TinyEventItem.GIVE_MONEY:			this.doItemCommand( nextEvent.thingToDo ); break;				case TinyEventItem.TAKE_MONEY:			this.doItemCommand( nextEvent.thingToDo ); break;				case TinyEventItem.PLAY_ANIM:			this.doAnimation( nextEvent.thingToDo ); break;				case TinyEventItem.PLAY_SOUND:			this.doSound( nextEvent.thingToDo ); break;				case TinyEventItem.PLAY_MUSIC:			this.doMusic( nextEvent.thingToDo ); break;				case TinyEventItem.SET_FLAG:			this.doSetFlag( TinyEventFlag( nextEvent.thingToDo ) ); break;				case TinyEventItem.CLEAR_FLAG:			this.doClearFlag( TinyEventFlag( nextEvent.thingToDo ) ); break;				case TinyEventItem.WALK:				this.doWalk( nextEvent.thingToDo ); break;				case TinyEventItem.WARP:				this.doWarp( nextEvent.thingToDo ); break;				case TinyEventItem.REMOVE_TRIGGER:		this.doRemoveTrigger( nextEvent.thingToDo ); break;				case TinyEventItem.CHOOSE_STARTER:		this.doChooseStarter( nextEvent.thingToDo ); break;				case TinyEventItem.SET_POSITION:		this.doSetPosition( nextEvent.thingToDo ); break;				case TinyEventItem.DELAY:				this.doPause( nextEvent.thingToDo ); break;				case TinyEventItem.HEAL_ALL:			this.doHealAll(); break;				default: case TinyEventItem.END:		this.doEnd(); break;			}		}				private function doBattle( battle : TinyBattle ) : void		{			// TODO: implement			}		private function onBattleComplete(event : Event) : void 		{			// TODO: implement		}		private function doCondition( command : TinyConditionalCommand ) : void		{			this.logWithDepth( 'doCondition');						// Execute the command and run the resulting sequence as a sub-sequence			this.doSubSequence( command.execute() );		}		private function onSequenceEnd( event : TinySequenceEvent = null ) : void 		{			this.logWithDepth( 'onSequenceEnd' );							// Clean up			this.removeEventListener( TinySequenceEvent.SEQUENCE_END, onSequenceEnd );			this.dispatchEvent ( new TinySequenceEvent( TinySequenceEvent.SEQUENCE_END ) );						// All done if we're at the top-most event level			if ( this.eventDepth == 0 ) 			{				this.logWithDepth( 'all sequences complete' );				this.dispatchEvent( new Event( Event.COMPLETE ) );			}		}				private function doSubSequence( sequence : TinyEventSequence ) : void		{			this.logWithDepth( 'doSubSequence: ' + sequence.eventName );						// Increase the sequence's event depth 			sequence.eventDepth = this.eventDepth + 1;						// Listen for various complete events			sequence.addEventListener( Event.COMPLETE, onSubSequenceComplete );			sequence.addEventListener( TinySequenceEvent.SEQUENCE_END, onSequenceEnd );			this.addEventListener( TinySequenceEvent.SEQUENCE_END, onSequenceEnd );						// Start the sequence			this.addChild( sequence );			sequence.startSequence();		}				private function onSubSequenceComplete(event : Event) : void 		{			this.logWithDepth( 'onSubSequenceComplete' );						// Next!			this.doNextCommand();		}		private function doDialog( dialog : TinyDialogBox ) : void		{			this.logWithDepth( 'doDialog' );						// Add and start dialog			this.currentDialog = dialog;			this.currentDialog.x = 8;			this.currentDialog.y = 104;			this.currentDialog.show();			this.addChild( this.currentDialog );						// Pass control to the dialog			TinyInputManager.getInstance().setTarget( this.currentDialog );						// Wait for the dialog to be completed before continuing to the next item in the sequence						this.currentDialog.addEventListener( Event.COMPLETE, this.onDialogComplete );		}		private function onDialogComplete( event : Event ) : void 		{			this.logWithDepth( 'onDialogComplete' );						// Clean up			this.currentDialog.removeEventListener( Event.COMPLETE, onDialogComplete );			this.removeChild( this.currentDialog );			this.currentDialog = null;						// Remove control from the dialog			TinyInputManager.getInstance().setTarget( null );						// Next!			this.doNextCommand();		}			private function doAddNPC( npcCommand : TinyAddNPCCommand ) : void		{			this.logWithDepth( 'doAddNPC' );				// Execute command			npcCommand.execute();						// Next!			this.doNextCommand();		}				private function doRemoveNPC( npcName : String ) : void		{			this.logWithDepth( 'doRemoveNPC' );				// Remove npc from the map			TinyMapManager.getInstance().currentMap.removeNPCByName( npcName );									// Next!			this.doNextCommand();		}				private function doShowEmote( emoteCommand: TinyEmoteCommand ) : void		{			this.logWithDepth( 'doShowEmote' );				// Execute command			emoteCommand.execute();						// Next!			this.doNextCommand();		}				private function doHideEmote( emoteCommand: TinyEmoteCommand ) : void		{			this.logWithDepth( 'doHideEmote' );				// Execute command			emoteCommand.execute();						// Next!			this.doNextCommand();		}				private function doSetFacing( facingCommand : TinySetFacingCommand ) : void		{			this.logWithDepth( 'doSetFacing' );				// Execute command			facingCommand.execute();						// Next!			this.doNextCommand();		}				private function doItemCommand( itemCommand : TinyItemCommand ) : void		{			this.logWithDepth( 'doItemCommand' );						// Execute command			itemCommand.execute();									// Next!			this.doNextCommand();			}		private function doAnimation( animCommand : TinyAnimCommand ) : void		{			this.logWithDepth( 'doAnimation' );						this.currentAnimCommand = animCommand;						this.currentAnimCommand.addEventListener( Event.COMPLETE, this.onAnimationComplete );			this.currentAnimCommand.execute();		}		private function onAnimationComplete( event : Event ) : void 		{			this.logWithDepth( 'onAnimComplete' );						// Clean up			this.currentAnimCommand.removeEventListener( Event.COMPLETE, this.onAnimationComplete );			this.currentAnimCommand = null;						// Next!			this.doNextCommand();		}		private function doSound( sound : Sound ) : void		{			this.logWithDepth( 'doSound' );						sound.play();						// Next!			this.doNextCommand();		}				private function doMusic( musicCommand : TinyMusicCommand ) : void		{			var songName : String = musicCommand.songName;						this.logWithDepth( 'doMusic: ' + songName );						// Handle various types of music playing			if ( songName == 'MAP' ) {				TinyAudioManager.getInstance().resumeMapMusic();			} else if ( musicCommand.interrupt ) {				TinyAudioManager.getInstance().playInterruptMusic( TinyAudioManager.getInstance().getMusicByName( songName ) );			} else {				TinyAudioManager.getInstance().setSong( TinyAudioManager.getInstance().getMusicByName( songName ), true );			}						// Next!						this.doNextCommand();		}
		private function doSetFlag( targetFlag : TinyEventFlag ) : void		{			this.logWithDepth( 'doSetFlag: ' + targetFlag.name );						// Set the flag			targetFlag.value = true;						// Next!			this.doNextCommand();		}				private function doClearFlag( targetFlag : TinyEventFlag ) : void		{			this.logWithDepth( 'doClearFlag: ' + targetFlag.name );						// Clear the flag			targetFlag.value = false;						// Next!			this.doNextCommand();		}				private function doPause( pauseTime : int ) : void		{			this.logWithDepth( 'doPause: ' + pauseTime + ' frames' );						// Do next command after a pause			TweenLite.delayedCall( pauseTime, this.doNextCommand, null, true );		}				private function doWalk( walkCommand : TinyWalkCommand ) : void		{			this.logWithDepth( 'doWalk' );						// Execute walk command			walkCommand.addEventListener( TinySequenceEvent.WALK_COMPLETE, this.onWalkComplete );			walkCommand.execute();		}				private function doWarp( warpCommand : TinyWarpCommand ) : void		{			this.logWithDepth( 'doWarp' );						// Tell the MapManager to excute the warp command			TinyMapManager.getInstance().executeWarpEventCommand( warpCommand );						// Next!			this.doNextCommand();		}		private function onWalkComplete( event : TinySequenceEvent ) : void 		{			this.logWithDepth( 'onWalkComplete: ' + event.param.targetSprite.id );						// Clean up			event.param.removeEventListener( TinySequenceEvent.WALK_COMPLETE, this.onWalkComplete );						// Next!			this.doNextCommand();		}				private function doRemoveTrigger( triggerName : String ) : void		{			this.logWithDepth( 'doRemoveTrigger: ' + triggerName );						// Ask the current map to remove the trigger			TinyMapManager.getInstance().currentMap.removeTriggerByName( triggerName );						// Next!			this.doNextCommand();		}				private function doChooseStarter( command : TinyChooseStarterCommand ) : void		{			this.logWithDepth( 'doChooseStarter: ' + command.monName );						// Execute the command			command.addEventListener( TinySequenceEvent.CHOICE_COMPLETE, this.onChooseStarterComplete );			command.execute( this );		}				private function onChooseStarterComplete( event : TinySequenceEvent ) : void		{			this.logWithDepth( 'onChooseStarterComplete' );						// Run the resulting complete sequence as a sub-sequence			this.doSubSequence( event.param as TinyEventSequence );		}				private function doSetPosition( command : TinySetPosCommand ) : void		{			this.logWithDepth( 'doSetPosition' );						// Execute command			command.execute();						// Next!			this.doNextCommand();		}				private function doHealAll() : void		{			this.logWithDepth( 'doHealAll' );						// TODO: Implement for dikemon party						// Next!			this.doNextCommand();		}		private function doEnd() : void		{			this.logWithDepth( 'doEnd' );						this.dispatchEvent( new Event( Event.COMPLETE ) );		}				private function logWithDepth( message : String ) : void		{			TinyLogManager.log( ' - depth ' + this.eventDepth + ' - ' + message, this );		}	}}