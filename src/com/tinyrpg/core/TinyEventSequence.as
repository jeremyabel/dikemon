package com.tinyrpg.core {		import com.greensock.TweenLite;	import com.greensock.easing.SteppedEase;	import com.greensock.plugins.ColorTransformPlugin;	import com.greensock.plugins.TintPlugin;	import com.greensock.plugins.TweenPlugin;	import com.tinyrpg.data.TinyAppSettings;	import com.tinyrpg.data.TinyEnemyDataList;	import com.tinyrpg.data.TinyEventFlag;	import com.tinyrpg.data.TinyEventFlagData;	import com.tinyrpg.data.TinyItemDataList;	import com.tinyrpg.display.TinySpriteSheet;	import com.tinyrpg.display.misc.MaskGradient;	import com.tinyrpg.display.misc.Pixelsplosion;	import com.tinyrpg.events.TinyInputEvent;	import com.tinyrpg.events.TinySequenceEvent;	import com.tinyrpg.managers.TinyAudioManager;	import com.tinyrpg.managers.TinyInputManager;	import com.tinyrpg.maps.TinyCastleMap;	import com.tinyrpg.misc.TinyAddNPCCommand;	import com.tinyrpg.misc.TinyAnimCommand;	import com.tinyrpg.misc.TinyAttackCommand;	import com.tinyrpg.misc.TinyEventItem;	import com.tinyrpg.misc.TinyFXCommand;	import com.tinyrpg.misc.TinyFlashCommand;	import com.tinyrpg.misc.TinyItemCommand;	import com.tinyrpg.misc.TinyMusicCommand;	import com.tinyrpg.misc.TinySetPosCommand;	import com.tinyrpg.misc.TinyWalkCommand;	import com.tinyrpg.ui.TinyBattleItemGetBox;	import com.tinyrpg.ui.TinyDialogBox;	import com.tinyrpg.ui.TinyDialogSelectList;	import com.tinyrpg.ui.TinyNoticeBox;	import com.tinyrpg.utils.TinyLogManager;	import com.tinyrpg.utils.TinyMath;	import flash.display.Bitmap;	import flash.display.Sprite;	import flash.events.Event;	import flash.geom.Point;	import flash.media.Sound;	import flash.utils.ByteArray;	/**	 * @author jeremyabel	 */	public class TinyEventSequence extends Sprite	{		[Embed(source='../../../../bin/xml/Events.xml', mimeType='application/octet-stream')]		public static const Events_XML : Class;				public static const TYPE_FLAG   : String = 'TYPE_FLAG';		public static const TYPE_ITEM   : String = 'TYPE_ITEM';		public static const TYPE_GOLD   : String = 'TYPE_GOLD';		public static const TYPE_PLAYER : String = 'TYPE_PLAYER';				public static var outParty : Array = [];				private var eventSequence : Array = [];		private var eventXMLData  : XML;				private var currentDialog   	: TinyDialogBox;		public  var currentBattle   	: TinyBattle;		private var currentWalkCommand	: TinyWalkCommand;		private var currentFXCommand	: TinyFXCommand;		private var currentAnimCommand	: TinyAnimCommand;		private var currentNotice		: TinyNoticeBox;		private var currentFlashCommand : TinyFlashCommand;		private var currentBox 			: TinyBattleItemGetBox;				private var theNuke				: TinySpriteSheet;		private var theHybrid			: TinyFriendSprite;		private var theMask				: Sprite;				public var conditionFlag 	: String = '';		public var conditionItem	: String = '';		public var conditionPlayer  : String = '';		public var conditionType  	: String = '';		public var conditionGold 	: uint = 0;				public var elseSequence  : TinyEventSequence;		public var eventDepth	 : int = 0;
		public var eventName	 : String;
		public function TinyEventSequence() : void		{			TweenPlugin.activate([ColorTransformPlugin, TintPlugin]);						// Get dialog XML data			var byteArray : ByteArray = (new TinyEventSequence.Events_XML) as ByteArray;			var string : String = byteArray.readUTFBytes(byteArray.length);			this.eventXMLData = new XML(string);							// Add events			this.addEventListener(TinyInputEvent.CONTROL_ADDED, onControlAdded);		}				public static function newFromEventName(eventName : String) : TinyEventSequence		{			var newEventSequence : TinyEventSequence = new TinyEventSequence;			TinyLogManager.log('newFromEventName: ' + eventName, newEventSequence);						newEventSequence.eventName = eventName;						// Find in XML			var eventList : XMLList = newEventSequence.eventXMLData.child('EVENT_' + eventName).child('SEQUENCE');			for each (var event : XML in eventList.children())			{				var eventType : String = event.name();								switch (eventType)				{					case TinyEventItem.BATTLE:						newEventSequence.addBattle(event);						break;					case TinyEventItem.CONDITIONAL:						newEventSequence.addCondition(event);						break;					case TinyEventItem.DIALOG:						newEventSequence.addDialog(event);						break;					case TinyEventItem.DIALOG_CHOICE:						newEventSequence.addDialogChoice(event);						break;					case TinyEventItem.DIALOG_CUSTOM:						newEventSequence.addDialog(event, true);						break;					case TinyEventItem.ADD_NPC:						newEventSequence.addNPC(event);						break;					case TinyEventItem.REMOVE_NPC:						newEventSequence.removeNPC(event);						break;					case TinyEventItem.ATTACK:						newEventSequence.addAttack(event);						break;					case TinyEventItem.SUB_SEQUENCE:						newEventSequence.addSubSequence(event);						break;					case TinyEventItem.GIVE_ITEM:						newEventSequence.addGiveItem(event);						break;					case TinyEventItem.TAKE_GOLD:						newEventSequence.addTakeGold(event);						break;					case TinyEventItem.PLAY_ANIM:						newEventSequence.addAnimation(event);						break;					case TinyEventItem.PLAY_FX:						newEventSequence.addFX(event);						break;					case TinyEventItem.PLAY_SOUND:						newEventSequence.addSound(event);						break;					case TinyEventItem.PLAY_MUSIC:						newEventSequence.addMusic(event);						break;					case TinyEventItem.PLAY_NUKE:						newEventSequence.addNuke();						break;					case TinyEventItem.FLASH_SCREEN:						newEventSequence.addFlash(event);						break;					case TinyEventItem.FADE_FLASH_OUT:						newEventSequence.addFlashFade(event);						break;					case TinyEventItem.OPEN_DOOR:						newEventSequence.addOpenDoor();						break;					case TinyEventItem.SET_FLAG:						newEventSequence.addFlagSet(event);						break;					case TinyEventItem.DELAY:						newEventSequence.addPause(event);						break;					case TinyEventItem.RECRUIT:						newEventSequence.addRecruit(event);						break;					case TinyEventItem.HEAL_ALL:						newEventSequence.addHealAll();						break;					case TinyEventItem.EVERYBODY_OUT:						newEventSequence.addEverybodyOut();						break;					case TinyEventItem.WALK:						newEventSequence.addWalk(event);						break;					case TinyEventItem.SET_POSITION:						newEventSequence.addSetPosition(event);						break;					case TinyEventItem.END:						newEventSequence.addEnd();						break;					case TinyEventItem.FINAL_END:						break;					case TinyEventItem.SUCK_TO_CENTER:						newEventSequence.addSuckToCenter();						break;					case TinyEventItem.SHOW_HYBRID:						newEventSequence.addShowHybrid();						break;				}			}			return newEventSequence;		}				public static function newFromXML(xmlData : XML) : TinyEventSequence		{			var newEventSequence : TinyEventSequence = new TinyEventSequence;						// Set conditional flag?			if (xmlData.child('FLAG') && xmlData.child('FLAG').toString() != '') {				newEventSequence.conditionFlag = xmlData.child('FLAG').toString();				newEventSequence.conditionType = TinyEventSequence.TYPE_FLAG;				TinyLogManager.log('newFromXML: condition = ' + newEventSequence.conditionFlag, newEventSequence);			} 						// Set conditional item?			if (xmlData.child('ITEM') && xmlData.child('ITEM').toString() != '') {				newEventSequence.conditionItem = xmlData.child('ITEM').toString();				newEventSequence.conditionType = TinyEventSequence.TYPE_ITEM;				TinyLogManager.log('newFromXML: condition = has 1 ' + newEventSequence.conditionItem, newEventSequence);			}						// Set conditional gold ammount?			if (xmlData.child('GOLD') && xmlData.child('GOLD').toString() != '') {				newEventSequence.conditionGold = uint(xmlData.child('GOLD').toString());				newEventSequence.conditionType = TinyEventSequence.TYPE_GOLD;				TinyLogManager.log('newFromXML: condition = has ' + newEventSequence.conditionGold + ' bucks', newEventSequence);			}						// Set conditional player name?			if (xmlData.child('PLAYER') && xmlData.child('PLAYER').toString() != '') {				newEventSequence.conditionPlayer = xmlData.child('PLAYER').toString();				newEventSequence.conditionType = TinyEventSequence.TYPE_PLAYER;				TinyLogManager.log('newFromXML: condition = name is ' + newEventSequence.conditionPlayer, newEventSequence);			}						var eventList : XMLList = xmlData.child('SEQUENCE');						for each (var event : XML in eventList.children())			{				var eventType : String = event.name();								switch (eventType)				{					case TinyEventItem.BATTLE:						newEventSequence.addBattle(event);						break;					case TinyEventItem.CONDITIONAL:						newEventSequence.addCondition(event);						break;					case TinyEventItem.DIALOG:						newEventSequence.addDialog(event);						break;					case TinyEventItem.DIALOG_CHOICE:						newEventSequence.addDialogChoice(event);						break;					case TinyEventItem.DIALOG_CUSTOM:						newEventSequence.addDialog(event, true);						break;					case TinyEventItem.ADD_NPC:						newEventSequence.addNPC(event);						break;					case TinyEventItem.REMOVE_NPC:						newEventSequence.removeNPC(event);						break;					case TinyEventItem.ATTACK:						newEventSequence.addAttack(event);						break;					case TinyEventItem.SUB_SEQUENCE:						newEventSequence.addSubSequence(event);						break;					case TinyEventItem.GIVE_ITEM:						newEventSequence.addGiveItem(event);						break;					case TinyEventItem.TAKE_GOLD:						newEventSequence.addTakeGold(event);						break;					case TinyEventItem.PLAY_ANIM:						newEventSequence.addAnimation(event);						break;					case TinyEventItem.PLAY_FX:						newEventSequence.addFX(event);						break;					case TinyEventItem.PLAY_NUKE:						newEventSequence.addNuke();						break;					case TinyEventItem.PLAY_SOUND:						newEventSequence.addSound(event);						break;					case TinyEventItem.PLAY_MUSIC:						newEventSequence.addMusic(event);						break;					case TinyEventItem.FLASH_SCREEN:						newEventSequence.addFlash(event);						break;					case TinyEventItem.FADE_FLASH_OUT:						newEventSequence.addFlashFade(event);						break;					case TinyEventItem.OPEN_DOOR:						newEventSequence.addOpenDoor();						break;					case TinyEventItem.SET_FLAG:						newEventSequence.addFlagSet(event);						break;					case TinyEventItem.DELAY:						newEventSequence.addPause(event);						break;					case TinyEventItem.RECRUIT:						newEventSequence.addRecruit(event);						break;					case TinyEventItem.HEAL_ALL:						newEventSequence.addHealAll();						break;					case TinyEventItem.EVERYBODY_OUT:						newEventSequence.addEverybodyOut();						break;					case TinyEventItem.WALK:						newEventSequence.addWalk(event);						break;					case TinyEventItem.SET_POSITION:						newEventSequence.addSetPosition(event);						break;					case TinyEventItem.END:						newEventSequence.addEnd();						break;					case TinyEventItem.FINAL_END:						newEventSequence.addFinalEnd();						break;					case TinyEventItem.SUCK_TO_CENTER:						newEventSequence.addSuckToCenter();						break;					case TinyEventItem.SHOW_HYBRID:						newEventSequence.addShowHybrid();						break;				}			}						// If there's an ELSE sequence, addd it to the list 			if (xmlData.child('ELSE').toString() != '')			{				// Convert from XMLList to XML				var xmlString : String = xmlData.child('ELSE').child('SEQUENCE').toXMLString();				xmlString = '<EVENT>' + xmlString + '</EVENT>';				var newXML : XML = new XML(xmlString);								var newElseSequence : TinyEventSequence = TinyEventSequence.newFromXML(newXML);				newEventSequence.elseSequence = newElseSequence;			}						return newEventSequence;		}			 	private function onControlAdded(e : TinyInputEvent) : void		{			TinyLogManager.log('onControlAdded', this);						TinyInputManager.getInstance().addEventListener(TinyInputEvent.ACCEPT, onAccept);			this.addEventListener(TinyInputEvent.CONTROL_REMOVED, onControlRemoved);			this.removeEventListener(TinyInputEvent.CONTROL_ADDED, onControlAdded);		}		private function onControlRemoved(e : TinyInputEvent) : void		{			TinyLogManager.log('onControlRemoved', this);						TinyInputManager.getInstance().removeEventListener(TinyInputEvent.ACCEPT, onAccept);			this.removeEventListener(TinyInputEvent.CONTROL_REMOVED, onControlRemoved);			this.addEventListener(TinyInputEvent.CONTROL_ADDED, onControlAdded);		}		private function onAccept(event : TinyInputEvent) : void 		{			TinyLogManager.log('onAccept', this);		}		public function startSequence() : void		{			TinyLogManager.log('DEPTH: ' + this.eventDepth + ' startSequence', this);			this.addEventListener(TinySequenceEvent.SEQUENCE_END, onSequenceEnd);			this.doNextCommand();		}				///////////////////////////////////////////////////////////////////////////////////////////////		// ADDING EVENTS TO THE SEQUENCE		///////////////////////////////////////////////////////////////////////////////////////////////				private function addBattle(xmlData : XML) : void		{						// Get enemies from XML			var enemyString : String = xmlData.child('ENEMIES').text();			var enemyList : Array = enemyString.split(',');						TinyLogManager.log('addBattle: ' + enemyString, this);						// Get TinyStatsEntities from the xml string list			var enemyArray : Array = [];			for each (var enemyName : String in enemyList) {				trace(enemyName);				var newEnemy : TinyStatsEntity = TinyEnemyDataList.getInstance().getEnemyByName(enemyName);				enemyArray.push(newEnemy);			}						// Get various parameters			var canRun : Boolean = (xmlData.child('RUNABLE').toString().toUpperCase() == 'TRUE');			var forceEnd : int = int(xmlData.child('FORCE_END').toString());			var impossible : Boolean = (xmlData.child('IMPOSSIBLE').toString().toUpperCase() == 'TRUE');			var forceStart : String = xmlData.child('FORCE_START').toString();			var finalBattle : Boolean = (xmlData.child('FINAL').toString().toUpperCase() == 'TRUE');			var boss : Boolean = (xmlData.child('BOSS').toString().toUpperCase() == 'TRUE');			var battleEvent : String = '';			var eventCondition : String = '';						// Parameters for in-battle events			if (xmlData.child('IN_BATTLE_EVENT').toXMLString() != '') {				battleEvent = xmlData.child('IN_BATTLE_EVENT').child('NAME').toString();				eventCondition = xmlData.child('IN_BATTLE_EVENT').child('CONDITION').toString();			}						// Make new battle			var newBattle : TinyBattle = new TinyBattle(enemyArray, canRun, forceEnd, impossible, finalBattle, boss, forceStart, battleEvent, eventCondition);			var newEventItem : TinyEventItem = new TinyEventItem(TinyEventItem.BATTLE, newBattle);						// Add to sequence			this.eventSequence.push(newEventItem);		}		private function addCondition(xmlData : XML) : void		{			TinyLogManager.log('addCondition', this);						// Make new event sequence			var newSequence : TinyEventSequence = TinyEventSequence.newFromXML(xmlData);			var newEventItem : TinyEventItem = new TinyEventItem(TinyEventItem.CONDITIONAL, newSequence);						// Add to sequence			this.eventSequence.push(newEventItem);		}		private function addDialog(xmlData : XML, custom : Boolean = false) : void		{			TinyLogManager.log('addDialog', this);								// Make new dialog			var newDialog : TinyDialogBox = TinyDialogBox.newFromXML(xmlData);			var newEventItem : TinyEventItem = new TinyEventItem(TinyEventItem.DIALOG, newDialog);			if (custom) {				newDialog = TinyDialogBox.newFromXML(xmlData, int(xmlData.child('WIDTH').toString()), int(xmlData.child('HEIGHT').toString()));				newDialog.x = int(xmlData.child('X').toString());				newDialog.y = int(xmlData.child('Y').toString());				newDialog.time = int(xmlData.child('TIME').toString());				newEventItem = new TinyEventItem(TinyEventItem.DIALOG_CUSTOM, newDialog); 			}						// Add to sequence			this.eventSequence.push(newEventItem);		}				private function addDialogChoice(xmlData : XML) : void		{			TinyLogManager.log('addDialogChoice', this);						// Make new dialog choice			var newDialogChoice : TinyDialogSelectList = TinyDialogSelectList.newFromXML(xmlData);			var newEventItem : TinyEventItem = new TinyEventItem(TinyEventItem.DIALOG_CHOICE, newDialogChoice);						// Add to sequence			this.eventSequence.push(newEventItem);		}				private function addNPC(xmlData : XML) : void		{			TinyLogManager.log('addNPC', this);						// Make new add NPC command						var newNPCCommand : TinyAddNPCCommand = TinyAddNPCCommand.newFromXML(xmlData);			var newEventItem : TinyEventItem = new TinyEventItem(TinyEventItem.ADD_NPC, newNPCCommand);						// Add to sequence			this.eventSequence.push(newEventItem);		}				private function removeNPC(xmlData : XML) : void		{			TinyLogManager.log('removeNPC', this);						// Make new add NPC command						var newNPCCommand : TinyAddNPCCommand = TinyAddNPCCommand.newFromXML(xmlData);			var newEventItem : TinyEventItem = new TinyEventItem(TinyEventItem.REMOVE_NPC, newNPCCommand);						// Add to sequence			this.eventSequence.push(newEventItem);		}				private function addAttack(xmlData : XML) : void		{			TinyLogManager.log('addAttack', this);						// Make new attack command			var newAttackCommand : TinyAttackCommand = TinyAttackCommand.newFromXML(xmlData);			var newEventItem : TinyEventItem = new TinyEventItem(TinyEventItem.ATTACK, newAttackCommand);						// Add to sequence			this.eventSequence.push(newEventItem);		}				private function addSubSequence(xmlData : XML) : void		{			TinyLogManager.log('addSubSequence', this);						// Make new sequence			var newSequence : TinyEventSequence = TinyEventSequence.newFromEventName(xmlData.toString());			var newEventItem : TinyEventItem = new TinyEventItem(TinyEventItem.SUB_SEQUENCE, newSequence);						// Add to sequence			this.eventSequence.push(newEventItem);		}		private function addTakeGold(xmlData : XML) : void		{			TinyLogManager.log('addTakeItem', this);						// Get params from XML			var take : Boolean = true;			var gold : int = int(xmlData.toString());						// Make new item command			var newItemCommand : TinyItemCommand = new TinyItemCommand(take, null, gold);			var newEventItem : TinyEventItem = new TinyEventItem(TinyEventItem.TAKE_GOLD, newItemCommand);						// Add to sequence			this.eventSequence.push(newEventItem);			}		private function addGiveItem(xmlData : XML) : void		{			TinyLogManager.log('addGiveItem', this);						// Make new event item			var item : TinyItem = TinyItemDataList.getInstance().getItemByName(xmlData.toString());			var newEventItem : TinyEventItem = new TinyEventItem(TinyEventItem.GIVE_ITEM, item);						// Add to sequence			this.eventSequence.push(newEventItem);		}		private function addAnimation(xmlData : XML) : void		{			TinyLogManager.log('addAnimation', this);							// Make new animation command			var newAnimCommand : TinyAnimCommand = TinyAnimCommand.newFromXML(xmlData);			var isBattle : Boolean = (xmlData.child('BATTLE').toString() == 'TRUE');			var newEventItem : TinyEventItem = new TinyEventItem(TinyEventItem.PLAY_ANIM, newAnimCommand, isBattle);						// Add to sequence			this.eventSequence.push(newEventItem);		}				private function addFX(xmlData : XML) : void		{			TinyLogManager.log('addFX', this);						// Make new fx command			var newFXCommand : TinyFXCommand = TinyFXCommand.newFromXML(xmlData);			var isBattle : Boolean = (xmlData.child('BATTLE').toString() == 'TRUE');			var newEventItem : TinyEventItem = new TinyEventItem(TinyEventItem.PLAY_FX, newFXCommand, isBattle);						// Add to sequence			this.eventSequence.push(newEventItem);		}		private function addSound(xmlData : XML) : void		{			TinyLogManager.log('addSound', this);						// Make new sound			var newSound : Sound = TinyAudioManager.getSoundByName(xmlData.toString());			var isBattle : Boolean = (xmlData.child('BATTLE').toString() == 'TRUE');			var newEventItem : TinyEventItem = new TinyEventItem(TinyEventItem.PLAY_SOUND, newSound, isBattle);						// Add to sequence			this.eventSequence.push(newEventItem);		}				private function addMusic(xmlData : XML) : void		{			TinyLogManager.log('addMusic', this);						// Make new event item			var newMusicCommand : TinyMusicCommand = TinyMusicCommand.newFromXML(xmlData);			var newEventItem : TinyEventItem = new TinyEventItem(TinyEventItem.PLAY_MUSIC, newMusicCommand);						// Add to sequence			this.eventSequence.push(newEventItem);		}		private function addFlash(xmlData : XML) : void		{			TinyLogManager.log('addFlash', this);						// Make new flash command			var newFlashCommand : TinyFlashCommand = TinyFlashCommand.newFromXML(xmlData);			var newEventItem : TinyEventItem = new TinyEventItem(TinyEventItem.FLASH_SCREEN, newFlashCommand);						// Add to sequence			this.eventSequence.push(newEventItem);		}				private function addFlashFade(xmlData : XML) : void		{			TinyLogManager.log('addFlashFade', this);						// Make new event item			var newEventItem : TinyEventItem = new TinyEventItem(TinyEventItem.FADE_FLASH_OUT, int(xmlData.toString()));						// Add to sequence			this.eventSequence.push(newEventItem);		}				private function addNuke() : void		{			TinyLogManager.log('addNuke', this);						// Make new event item			var newEventItem : TinyEventItem = new TinyEventItem(TinyEventItem.PLAY_NUKE, null);						// Add to sequence			this.eventSequence.push(newEventItem);		}		private function addOpenDoor() : void		{			TinyLogManager.log('addOpenDoor', this);						// Make new event item			var newEventItem : TinyEventItem = new TinyEventItem(TinyEventItem.OPEN_DOOR, null);						// Add to sequence			this.eventSequence.push(newEventItem);		}		private function addFlagSet(xmlData : XML) : void		{			// Get flag from xml			var newFlag : TinyEventFlag = TinyEventFlagData.getInstance().getFlagByName(xmlData);			var newEventItem : TinyEventItem = new TinyEventItem(TinyEventItem.SET_FLAG, newFlag);			TinyLogManager.log('addFlagSet: ' + newFlag.name, this);						// Add to sequence			this.eventSequence.push(newEventItem);		}				private function addPause(xmlData : XML) : void		{			// Make new event item			var pauseTime : int = int(xmlData.toString());			var newEventItem : TinyEventItem = new TinyEventItem(TinyEventItem.DELAY, pauseTime);						TinyLogManager.log('addPause: ' + pauseTime + ' frames', this); 						// Add to sequence			this.eventSequence.push(newEventItem);		}				private function addRecruit(xmlData : XML) : void		{			// Make new event item			var newRecruit : String = xmlData.toString();			var newEventItem : TinyEventItem = new TinyEventItem(TinyEventItem.RECRUIT, newRecruit);						TinyLogManager.log('addRecruit: ' + newRecruit, this);						// Add to sequence			this.eventSequence.push(newEventItem);		}				private function addHealAll() : void		{			TinyLogManager.log('addHealAll', this);						var newEventItem : TinyEventItem = new TinyEventItem(TinyEventItem.HEAL_ALL, null);						// Add to sequence			this.eventSequence.push(newEventItem);		}				private function addEverybodyOut() : void		{			TinyLogManager.log('addEverybodyOut', this);						// Make new event item			var newEventItem : TinyEventItem = new TinyEventItem(TinyEventItem.EVERYBODY_OUT, null);						// Add to sequence			this.eventSequence.push(newEventItem);		}		private function addWalk(xmlData : XML) : void		{			TinyLogManager.log('addWalk', this);						// Make new walk command			var newWalkCommand : TinyWalkCommand = TinyWalkCommand.newFromXML(xmlData);			var isBattle : Boolean = (xmlData.child('BATTLE').toString() == 'TRUE');			var newEventItem : TinyEventItem = new TinyEventItem(TinyEventItem.WALK, newWalkCommand, isBattle);						// Add to sequence			this.eventSequence.push(newEventItem);		}				private function addSetPosition(xmlData : XML) : void		{			TinyLogManager.log('addSetPosition', this);						// Make new command			var newCommand : TinySetPosCommand = TinySetPosCommand.newFromXML(xmlData);			var newEventItem : TinyEventItem = new TinyEventItem(TinyEventItem.SET_POSITION, newCommand);						// Add to sequence			this.eventSequence.push(newEventItem);		}		private function addEnd() : void		{			TinyLogManager.log('addEnd', this);						// Make new event item			var newEventItem : TinyEventItem = new TinyEventItem(TinyEventItem.END, null);						// Add to sequence			this.eventSequence.push(newEventItem);		}				private function addFinalEnd() : void		{			TinyLogManager.log('addFinalEnd', this);						// Make new event item			var newEventItem : TinyEventItem = new TinyEventItem(TinyEventItem.FINAL_END, null);						// Add to sequence			this.eventSequence.push(newEventItem);		}				private function addSuckToCenter() : void		{			TinyLogManager.log('addSuckToCenter', this);						// Make new event item			var newEventItem : TinyEventItem = new TinyEventItem(TinyEventItem.SUCK_TO_CENTER, null);						// Add to sequence			this.eventSequence.push(newEventItem);		}				private function addShowHybrid() : void		{			TinyLogManager.log('addShowHybrid', this);						// Make new event item			var newEventItem : TinyEventItem = new TinyEventItem(TinyEventItem.SHOW_HYBRID, null);						// Add to sequence			this.eventSequence.push(newEventItem);		}				///////////////////////////////////////////////////////////////////////////////////////////////		// THE MIDDLE MAN		///////////////////////////////////////////////////////////////////////////////////////////////				private function doNextCommand() : void		{			TinyLogManager.log('doNextCommand', this); 						// Force FieldMap depth sort			TinyFieldMap.getInstance().checkSpriteDepth(true);						var nextEvent : TinyEventItem = this.eventSequence.shift();							switch (nextEvent.type)			{				case TinyEventItem.BATTLE:					this.doBattle(TinyBattle(nextEvent.thingToDo));					break;				case TinyEventItem.CONDITIONAL:					this.doCondition(TinyEventSequence(nextEvent.thingToDo));					break;				case TinyEventItem.DIALOG:					this.doDialog(TinyDialogBox(nextEvent.thingToDo));					break;				case TinyEventItem.DIALOG_CHOICE:					this.doDialogChoice(nextEvent.thingToDo);					break;				case TinyEventItem.DIALOG_CUSTOM:					this.doDialog(TinyDialogBox(nextEvent.thingToDo), true, TinyDialogBox(nextEvent.thingToDo).time);					break;				case TinyEventItem.ADD_NPC:					this.doAddNPC(nextEvent.thingToDo);					break;				case TinyEventItem.REMOVE_NPC:					this.doRemoveNPC(nextEvent.thingToDo);					break;				case TinyEventItem.ATTACK:					this.doAttack(nextEvent.thingToDo);					break;				case TinyEventItem.SUB_SEQUENCE:					this.doSubSequence(nextEvent.thingToDo);					break;				case TinyEventItem.TAKE_GOLD:					this.doTakeGold(nextEvent.thingToDo);					break;				case TinyEventItem.GIVE_ITEM:					this.doGiveItem(nextEvent.thingToDo);					break;				case TinyEventItem.PLAY_ANIM:					this.doAnimation(nextEvent.thingToDo);					break;				case TinyEventItem.PLAY_FX:					this.doFX(nextEvent.thingToDo);					break;				case TinyEventItem.PLAY_SOUND:					this.doSound(nextEvent.thingToDo);					break;				case TinyEventItem.PLAY_MUSIC:					this.doMusic(nextEvent.thingToDo);					break;				case TinyEventItem.PLAY_NUKE:					this.doNuke();					break;				case TinyEventItem.FLASH_SCREEN:					this.doFlash(nextEvent.thingToDo);					break;				case TinyEventItem.FADE_FLASH_OUT:					this.doFlashFadeOut(nextEvent.thingToDo);					break;				case TinyEventItem.OPEN_DOOR:					this.doOpenDoor(); 					break;				case TinyEventItem.SET_FLAG:					this.doSetFlag(TinyEventFlag(nextEvent.thingToDo));					break;				case TinyEventItem.WALK:					this.doWalk(nextEvent.thingToDo);					break;				case TinyEventItem.EVERYBODY_OUT:					this.doEverybodyOut();					break;				case TinyEventItem.SET_POSITION:					this.doSetPosition(nextEvent.thingToDo);					break;				case TinyEventItem.DELAY:					this.doPause(nextEvent.thingToDo);					break;				case TinyEventItem.RECRUIT:					this.doRecruit(nextEvent.thingToDo);					break;				case TinyEventItem.HEAL_ALL:					this.doHealAll();					break;				default:				case TinyEventItem.END:					this.doEnd();					break;				case TinyEventItem.FINAL_END:					this.doFinalEnd();					break;				case TinyEventItem.SUCK_TO_CENTER:					this.doSuckToCenter();					break;				case TinyEventItem.SHOW_HYBRID:					this.doShowHybrid();					break;			}		}						///////////////////////////////////////////////////////////////////////////////////////////////		// PERFORMING EVENTS FROM THE SEQUENCE		///////////////////////////////////////////////////////////////////////////////////////////////				private function doBattle(battle : TinyBattle) : void		{			TinyLogManager.log('DEPTH: ' + this.eventDepth + ' doBattle', this);							// Start battle			TinyInputManager.getInstance().setTarget(battle);			this.currentBattle = battle;			this.currentBattle.startBattle();			this.currentBattle.addEventListener(Event.COMPLETE, onBattleComplete);						this.addChild(currentBattle);		}		private function onBattleComplete(event : Event) : void 		{			TinyLogManager.log('onBattleComplete', this);			TinyInputManager.getInstance().setTarget(null);						if (!this.currentBattle.finalBattle) { 				TweenLite.to(this.currentBattle, 15, { alpha:0, ease:SteppedEase.create(5), useFrames:true, onComplete:this.onBattleOutComplete });				TinyFieldMap.checkWeirdThing();			}						// Next!			this.doNextCommand();		}				private function onBattleOutComplete() : void		{			TinyLogManager.log('onBattleOutComplete', this);			this.removeChild(currentBattle);			this.currentBattle.removeEventListener(Event.COMPLETE, onBattleComplete);			this.currentBattle = null;		}		private function doCondition(sequence : TinyEventSequence) : void		{			TinyLogManager.log('DEPTH: ' + this.eventDepth + ' doCondition: ' + sequence.conditionFlag + ', ' + sequence.conditionType, this);			trace(sequence.conditionPlayer);			// Check flag / item / gold / whatever			if ((sequence.conditionType == TinyEventSequence.TYPE_FLAG   && TinyEventFlagData.getInstance().getFlagStatusByName(sequence.conditionFlag)) || 				(sequence.conditionType == TinyEventSequence.TYPE_ITEM   && TinyPlayer.getInstance().inventory.hasItemNamed(sequence.conditionItem)) || 				(sequence.conditionType == TinyEventSequence.TYPE_GOLD   && TinyPlayer.getInstance().inventory.gold >= sequence.conditionGold) || 				(sequence.conditionType == TinyEventSequence.TYPE_PLAYER && TinyPlayer.getInstance().playerName.toUpperCase() == sequence.conditionPlayer.toUpperCase()) ||				(sequence.conditionFlag == '' && sequence.conditionItem == '' && sequence.conditionGold == 0 && sequence.conditionPlayer == '')) {				TinyLogManager.log('DEPTH: ' + this.eventDepth + ' doCondition: CONDITION MET; STARTING SEQUENCE', this);				this.addChild(sequence);				sequence.eventDepth = this.eventDepth + 1;				sequence.startSequence();								// Listen for various complete events				sequence.addEventListener(Event.COMPLETE, onSubSequenceComplete);				sequence.addEventListener(TinySequenceEvent.SEQUENCE_END, onSequenceEnd);				this.addEventListener(TinySequenceEvent.SEQUENCE_END, onSequenceEnd);			}			// Otherwise, run the else sequence 			else if (sequence.elseSequence) {				TinyLogManager.log('DEPTH: ' + this.eventDepth + ' doCondition: CONDITION NOT MET; STARTING ELSE SEQUENCE', this);				this.addChild(sequence.elseSequence);				sequence.elseSequence.eventDepth = this.eventDepth + 1;				sequence.elseSequence.startSequence();								// Listen for various complete events				sequence.elseSequence.addEventListener(Event.COMPLETE, onSubSequenceComplete);				sequence.elseSequence.addEventListener(TinySequenceEvent.SEQUENCE_END, onSequenceEnd);				this.addEventListener(TinySequenceEvent.SEQUENCE_END, onSequenceEnd);			}			// Otherwise just continue			else {				TinyLogManager.log('DEPTH: ' + this.eventDepth + ' doCondition: CONDITION NOT MET; STARTING NEXT COMMAND', this);				this.doNextCommand();			}		}		private function onSequenceEnd(event : TinySequenceEvent) : void 		{			TinyLogManager.log('DEPTH: ' + this.eventDepth + ' onSequenceEnd', this);			this.removeEventListener(TinySequenceEvent.SEQUENCE_END, onSequenceEnd);			this.dispatchEvent(new TinySequenceEvent(TinySequenceEvent.SEQUENCE_END));						// All done if we're at the top-most event level			if (this.eventDepth == 0) {				TinyLogManager.log('REACHED THE TOP! ALL DONE!', this);				this.dispatchEvent(new Event(Event.COMPLETE));			}		}				private function doSubSequence(sequence : TinyEventSequence) : void		{			TinyLogManager.log('DEPTH: ' + this.eventDepth + ' doSubSequence', this);						this.addChild(sequence);			sequence.eventDepth = this.eventDepth + 1;			sequence.startSequence();						// Listen for various complete events			sequence.addEventListener(Event.COMPLETE, onSubSequenceComplete);			sequence.addEventListener(TinySequenceEvent.SEQUENCE_END, onSequenceEnd);			this.addEventListener(TinySequenceEvent.SEQUENCE_END, onSequenceEnd);		}				private function onSubSequenceComplete(event : Event) : void 		{			TinyLogManager.log('DEPTH: ' + this.eventDepth + ' onSubSequenceComplete', this);			this.doNextCommand();		}		private function doDialog(dialog : TinyDialogBox, custom : Boolean = false, time : int = 0) : void		{			TinyLogManager.log('DEPTH: ' + this.eventDepth + ' doDialog', this);						// Add and start dialog			this.currentDialog = dialog;			var delayTime : int = this.currentDialog.battle ? 10 : 0;			TinyInputManager.getInstance().setTarget(this.currentDialog);						if (!custom) {				this.currentDialog.x = int((TinyAppSettings.STAGE_WIDTH / 2) - (dialog.width / 2)) + 3;				this.currentDialog.y = TinyStatsEntity(TinyPlayer.getInstance().fullParty.party[0]).graphics.y > 128 ? 16 : 170;			}						TweenLite.delayedCall(delayTime, this.currentDialog.show, null, true);			this.addChild(this.currentDialog);						if (!custom) {				dialog.addEventListener(Event.COMPLETE, onDialogComplete);			} else {				this.addEventListener(TinySequenceEvent.DIALOG_COMPLETE, onDialogComplete);				TweenLite.delayedCall(time, this.dispatchEvent, [new TinySequenceEvent(TinySequenceEvent.DIALOG_COMPLETE) ], true);			}						// Hide battle menu if we're in battle			if (this.currentDialog.battle) {				TinyBattle.battleMenu.hide();			}		}		private function onDialogComplete(event : Event) : void 		{			TinyLogManager.log('DEPTH: ' + this.eventDepth + ' onDialogComplete', this);						// Clean up			this.currentDialog.removeEventListener(Event.COMPLETE, onDialogComplete);			this.removeChild(this.currentDialog);			//this.currentDialog = null;						// Next!			this.doNextCommand();		}				private function doDialogChoice(dialog : TinyDialogSelectList) : void		{			TinyLogManager.log('DEPTH: ' + this.eventDepth + ' doDialogChoice', this);						this.currentDialog = dialog;			TinyInputManager.getInstance().setTarget(this.currentDialog);			this.currentDialog.x = int((TinyAppSettings.STAGE_WIDTH / 2) - (dialog.width / 2)) + 4; // I really don't know why it's +4 and not +3...			this.currentDialog.y = TinyStatsEntity(TinyPlayer.getInstance().fullParty.party[0]).graphics.y > 128 ? 16 : 170;			this.currentDialog.show(true);			this.currentDialog.addEventListener(TinyInputEvent.OPTION_ONE, onDialogChoiceOne);			this.currentDialog.addEventListener(TinyInputEvent.OPTION_TWO, onDialogChoiceTwo);			this.addChild(this.currentDialog);		}		private function onDialogChoiceOne(event : TinyInputEvent) : void 		{			TinyLogManager.log('DEPTH: ' + this.eventDepth + ' onDialogChoiceOne', this);						// Add choice two sequence to the list			this.eventSequence.unshift(new TinyEventItem(TinyEventItem.CONDITIONAL, TinyDialogSelectList(this.currentDialog).choiceOneSeq));						// Clean up			this.currentDialog.removeEventListener(TinyInputEvent.OPTION_ONE, onDialogChoiceOne);			this.currentDialog.removeEventListener(TinyInputEvent.OPTION_TWO, onDialogChoiceTwo);			this.removeChild(this.currentDialog);			this.currentDialog = null;						// Next!			this.doNextCommand();		}		private function onDialogChoiceTwo(event : TinyInputEvent) : void 		{			TinyLogManager.log('DEPTH: ' + this.eventDepth + ' onDialogChoiceTwo', this);						// Add choice two sequence to the list			this.eventSequence.unshift(new TinyEventItem(TinyEventItem.CONDITIONAL, TinyDialogSelectList(this.currentDialog).choiceTwoSeq));						// Clean up			this.currentDialog.removeEventListener(TinyInputEvent.OPTION_ONE, onDialogChoiceOne);			this.currentDialog.removeEventListener(TinyInputEvent.OPTION_TWO, onDialogChoiceTwo);			this.removeChild(this.currentDialog);			this.currentDialog = null;						// Next!			this.doNextCommand();		}		private function doAddNPC(npcCommand : TinyAddNPCCommand) : void		{			TinyLogManager.log('DEPTH: ' + this.eventDepth + ' doAddNPC', this);						// Handle battle event differently			if (npcCommand.battle) {				var npcSprite : TinyFriendSprite = TinyFriendSprite(TinyPlayer.getInstance().fullParty.getCharByName(npcCommand.battleName).graphics);				this.addChild(npcSprite);				this.currentBattle.addNPCSpriteAt(npcSprite, npcCommand.location.x, npcCommand.location.y, npcCommand.facing);			} else {				var npcLocation : Point = new Point();				if (npcCommand.specLocation) {					npcLocation.x = npcCommand.location.x;					npcLocation.y = npcCommand.location.y;				} else {					npcLocation.x = TinyFriendSprite(TinyStatsEntity(TinyPlayer.getInstance().fullParty.party[0]).graphics).x;					npcLocation.y = TinyFriendSprite(TinyStatsEntity(TinyPlayer.getInstance().fullParty.party[0]).graphics).y;				}				TinyFieldMap.getInstance().addNPCSpriteAt(TinyFriendSprite.newFromName(npcCommand.battleName), npcLocation.x, npcLocation.y, npcCommand.facing);			}						// Next!			this.doNextCommand();		}				private function doRemoveNPC(npcCommand : TinyAddNPCCommand) : void		{			TinyLogManager.log('DEPTH: ' + this.eventDepth + ' doRemoveNPC', this);						// Remove			TinyFieldMap.getInstance().removeNPCSprite(npcCommand.battleName);						// Next!			this.doNextCommand();		}				private function doAttack(attackCommand : TinyAttackCommand) : void		{			TinyLogManager.log('DEPTH: ' + this.eventDepth + ' doAttack', this);						// Get attacker and defender			var attacker : TinyStatsEntity = TinyPlayer.getInstance().fullParty.getCharByName(attackCommand.attacker);			var defender : TinyStatsEntity = TinyBattle.enemyParty.getCharByName(attackCommand.defender);						// Do attack. This will give control back to the battle and essentially end the event.			this.currentBattle.resolveTurn(true, attacker, defender, attackCommand.damage);		}				private function doTakeGold(itemCommand : TinyItemCommand) : void		{			TinyLogManager.log('DEPTH: ' + this.eventDepth + ' doTakeGold: ' + itemCommand.gold, this);						// Take the gold			TinyPlayer.getInstance().inventory.gold -= itemCommand.gold;						// Play sound			TweenLite.delayedCall(9, TinyAudioManager.play, [TinyAudioManager.BUY], true);						// Next!			TweenLite.delayedCall(14, this.doNextCommand, null, true);			}				private function doGiveItem(item : TinyItem) : void		{			TinyLogManager.log('DEPTH: ' + this.eventDepth + ' doTakeGold: ' + item.name, this);						var itemBox : TinyBattleItemGetBox = new TinyBattleItemGetBox(item, false);			this.currentBox = itemBox;			this.currentBox.x = 13; 			this.currentBox.y = 10;						this.addChild(this.currentBox);			this.currentBox.addEventListener(Event.COMPLETE, onGiveItemDone);			TinyInputManager.getInstance().setTarget(this.currentBox);			this.currentBox.show();		}		private function onGiveItemDone(event : Event) : void 		{			TinyLogManager.log('onGiveItemDone', this);								// Clean up			this.currentBox.removeEventListener(Event.COMPLETE, onGiveItemDone);			this.currentBox.hide();			this.removeChild(this.currentBox);							// Next!			this.doNextCommand();
		}
		private function doAnimation(animCommand : TinyAnimCommand) : void		{			TinyLogManager.log('DEPTH: ' + this.eventDepth + ' doAnimation', this);						this.currentAnimCommand = animCommand;						// Replace target if this is a battle command			if (this.currentAnimCommand.battle) {				var target : TinyFriendSprite = TinyFriendSprite(TinyPlayer.getInstance().fullParty.getCharByName(animCommand.battleName).graphics);				this.currentAnimCommand.target = target;			}						this.currentAnimCommand.addEventListener(Event.COMPLETE, onAnimComplete);			this.currentAnimCommand.execute();		}		private function onAnimComplete(event : Event) : void 		{			TinyLogManager.log('onAnimComplete', this);						// Clean up			this.currentAnimCommand.removeEventListener(Event.COMPLETE, onAnimComplete);			this.currentAnimCommand = null;						// Next!			this.doNextCommand();		}		private function doFX(fxCommand : TinyFXCommand) : void		{			TinyLogManager.log('DEPTH: ' + this.eventDepth + ' doFX', this);						this.currentFXCommand = fxCommand;						// Replace target if this is a battle command			if (this.currentFXCommand.battle) {				var target : TinyFriendSprite = TinyFriendSprite(TinyPlayer.getInstance().fullParty.getCharByName(fxCommand.battleName).graphics);				this.currentFXCommand.target = target;			}						this.currentFXCommand.addEventListener(Event.COMPLETE, onFXComplete);			this.currentFXCommand.execute();		}		private function onFXComplete(event : Event) : void 		{			TinyLogManager.log('DEPTH: ' + this.eventDepth + ' onFXComplete', this);						// Clean up			this.currentFXCommand.removeEventListener(Event.COMPLETE, onFXComplete);			this.currentFXCommand = null;						// Next!			this.doNextCommand();		}				private function doNuke() : void		{			TinyLogManager.log('DEPTH: ' + this.eventDepth + ' doNuke', this);						TinyInputManager.getInstance().setTarget(null);						// Add and play the explosion			this.theNuke = new TinySpriteSheet(new Pixelsplosion, 320, false, 3);			this.theNuke.x = 150;			this.theNuke.y = 140;			this.addChild(this.theNuke);			this.theNuke.playAndRemove(6);						// Remove when it's done						TweenLite.delayedCall(this.theNuke.length, this.onNukeComplete, null, true);			// Next!			TweenLite.delayedCall(1, this.doNextCommand, null, true);		}				private function onNukeComplete() : void		{			TinyLogManager.log('DEPTH: ' + this.eventDepth + ' onNukeComplete', this);						this.removeChild(this.theNuke);			this.theNuke = null;		}		private function doSound(sound : Sound) : void		{			TinyLogManager.log('DEPTH: ' + this.eventDepth + ' doSound', this);						sound.play();						// Next!			this.doNextCommand();		}				private function doMusic(musicCommand : TinyMusicCommand) : void		{			TinyLogManager.log('DEPTH: ' + this.eventDepth + ' doMusic', this);						var songName : String = musicCommand.songName;						// Handle various types of music playing			if (songName == 'MAP') {				TinyAudioManager.getInstance().resumeMapMusic();			} else if (musicCommand.interrupt) {				TinyAudioManager.getInstance().playInterruptMusic(TinyAudioManager.getInstance().getMusicByName(songName));			} else {				TinyAudioManager.getInstance().setSong(TinyAudioManager.getInstance().getMusicByName(songName), true);			}						// Next!						this.doNextCommand();		}				private function doFlash(flashCommand : TinyFlashCommand) : void		{			TinyLogManager.log('DEPTH: ' + this.eventDepth + ' doFlashCommand', this);						this.currentFlashCommand = flashCommand;			this.addChild(this.currentFlashCommand);			this.currentFlashCommand.addEventListener(Event.COMPLETE, onFlashComplete);			this.currentFlashCommand.execute();						if (this.currentFlashCommand.inOnly) {				this.doNextCommand();			}		}				private function doFlashFadeOut(time : int) : void		{			TinyLogManager.log('DEPTH: ' + this.eventDepth + ' doFlashFadeOut', this);						TweenLite.to(this.currentFlashCommand, time, { alpha:0, ease:SteppedEase.create(5), useFrames:true, onComplete:this.onFlashComplete, onCompleteParams:[null] });					}				private function onFlashComplete(event : Event) : void 		{			TinyLogManager.log('DEPTH: ' + this.eventDepth + ' onFlashComplete', this);						// Clean up			TinyLogManager.log('removing currentFlash', this);			this.removeChild(this.currentFlashCommand);			this.currentFlashCommand.removeEventListener(Event.COMPLETE, onFlashComplete);			this.currentFlashCommand = null;						this.doNextCommand();
		}
		private function doOpenDoor() : void		{			TinyLogManager.log('DEPTH: ' + this.eventDepth + ' doOpenDoor', this);						TinyCastleMap(TinyFieldMap.currentMap).openDoor();			TinyCastleMap(TinyFieldMap.currentMap).addEventListener(Event.COMPLETE, onDoorOpenComplete);		}		private function onDoorOpenComplete(event : Event) : void 		{			TinyLogManager.log('onDoorOpenComplete', this);						// Next!			this.doNextCommand();
		}
		private function doSetFlag(targetFlag : TinyEventFlag) : void		{			TinyLogManager.log('DEPTH: ' + this.eventDepth + ' doSetFlag: ' + targetFlag.name, this);			targetFlag.value = true;			this.doNextCommand();		}				private function doPause(pauseTime : int) : void		{			TinyLogManager.log('DEPTH: ' + this.eventDepth + ' doPause: ' + pauseTime, this);						// Do next command after a pause			TweenLite.delayedCall(pauseTime, this.doNextCommand, null, true);		}				private function doWalk(walkCommand : TinyWalkCommand) : void		{			TinyLogManager.log('DEPTH: ' + this.eventDepth + ' doWalk', this);						// Execute walk command			this.currentWalkCommand = walkCommand;			this.currentWalkCommand.addEventListener(Event.COMPLETE, onWalkComplete);			this.currentWalkCommand.execute();		}		private function onWalkComplete(event : Event) : void 		{			TinyLogManager.log('DEPTH: ' + this.eventDepth + ' onWalkComplete', this);						// Clean up			this.currentWalkCommand.removeEventListener(Event.COMPLETE, onWalkComplete);			this.currentWalkCommand = null;						// Next!			this.doNextCommand();		}				private function doSetPosition(command : TinySetPosCommand) : void		{			TinyLogManager.log('DEPTH: ' + this.eventDepth + ' doSetPosition', this);						// Execute command			command.execute();						// Next!			this.doNextCommand();		}				private function doRecruit(recruitName : String) : void		{			TinyLogManager.log('DEPTH: ' + this.eventDepth + 'doRecruit: ' + recruitName, this);						var charOne    : TinyStatsEntity;			var charTwo    : TinyStatsEntity;			var copier     : ByteArray;			var copyID_One : int = 0;			var copyID_Two : int = 0;						// SPECIAL CASE FOR ADDING DICKSWORD EVAN TO THE PARTY			if (recruitName.toUpperCase() == 'EVAN')			{				// Just add him to the end of the party as a 4th member				TinyPlayer.getInstance().party.addMember(TinyPlayer.getInstance().fullParty.getCharByName(recruitName));								// Get average level				var totalLevels : int = 0;				var levelCount  : int = 0;				for each (var char : TinyStatsEntity in TinyPlayer.getInstance().fullParty.party) {					if (char.recruited) {						totalLevels += char.stats.LVL;						levelCount++;					}				}								// Average party level				var avgLevel : int = int(totalLevels / levelCount);								// Level to current average level + 3				TinyPlayer.getInstance().fullParty.getCharByName(recruitName).stats.levelTo(avgLevel + 3);								// No notice needed				this.doNextCommand();				return;			}						// Only add if we haven't recruited them already			if (!TinyEventFlagData.getRecruitFlagByName(recruitName).value)			{				// Get average level				totalLevels = 0;				levelCount = 0;				for each (char in TinyPlayer.getInstance().fullParty.party) {					if (char.recruited) {						totalLevels += char.stats.LVL;						levelCount++;					}				}								// Average party level				avgLevel = int(totalLevels / levelCount);								// Level to current average level				TinyPlayer.getInstance().fullParty.getCharByName(recruitName).stats.levelTo(avgLevel);								// Play sound				TinyAudioManager.getInstance().playInterruptMusic(TinyAudioManager.RECRUIT);								// Add to current party if there's room				if (TinyPlayer.getInstance().fullParty.lengthRecruited < 3) 				{					// Add to normal party					TinyPlayer.getInstance().party.addMember(TinyPlayer.getInstance().fullParty.getCharByName(recruitName));										// Rejigger full party					charOne  = TinyPlayer.getInstance().fullParty.getCharByName(recruitName);					charTwo  = TinyPlayer.getInstance().fullParty.party[TinyPlayer.getInstance().fullParty.lengthRecruited];										TinyPlayer.getInstance().fullParty.party[TinyPlayer.getInstance().fullParty.party.indexOf(charOne)] = charTwo;					TinyPlayer.getInstance().fullParty.party[TinyPlayer.getInstance().fullParty.party.indexOf(charTwo)] = charOne;										// Deep copy character ID numbers					copier = new ByteArray();					copier.writeObject(charOne.idNumber);					copier.position = 0;					copyID_One = int(copier.readObject());					copier = new ByteArray();					copier.writeObject(charTwo.idNumber);					copier.position = 0;					copyID_Two = int(copier.readObject());										// Swap ID numbers					charOne.idNumber = copyID_Two;					charTwo.idNumber = copyID_One;				}								// Show join notice				this.currentNotice = new TinyNoticeBox(TinyPlayer.getInstance().fullParty.getCharByName(recruitName).name + ' joined your party!', 180);				this.currentNotice.addEventListener(TinyInputEvent.ACCEPT, onNoticeAccept);				TinyInputManager.getInstance().setTarget(this.currentNotice);				this.addChild(this.currentNotice);				this.currentNotice.x = 160 - int(this.currentNotice.width / 2);				this.currentNotice.y = 100;				this.currentNotice.show();								// Set coresponding event flag to true				TinyEventFlagData.getRecruitFlagByName(recruitName).value = true;			} else {				TinyLogManager.log('doRecruit: MEMBER ALREADY RECRUITED!!', this);				this.doNextCommand();			}		}		private function onNoticeAccept(event : TinyInputEvent) : void 		{			TinyLogManager.log('onNoticeAccept', this);						// Clean up			this.currentNotice.hide();			this.removeChild(this.currentNotice);			this.currentNotice.removeEventListener(TinyInputEvent.ACCEPT, onNoticeAccept);			this.currentNotice = null;						// Have we got everybody?! If so, add the "got everybody" event.			if (TinyPlayer.getInstance().fullParty.lengthRecruited == 8) 			{				var newSubSequence : TinyEventSequence = TinyEventSequence.newFromEventName('recruit_all_done');				this.doSubSequence(newSubSequence);			} else {				// Next!				this.doNextCommand();			}		}				private function doHealAll() : void		{			TinyLogManager.log('doHealAll', this);						for each (var member : TinyStatsEntity in TinyPlayer.getInstance().fullParty.party) { 				member.stats.HP = member.stats.MHP;			}							// Next!			this.doNextCommand();		}				private function doEverybodyOut() : void		{			TinyLogManager.log('DEPTH: ' + this.eventDepth + ' doEverybodyOut', this);						var spacing : int = 40;			var count : int = 0;			var maxDelay : int = 0;						// Rearrange party array to put player in the middle			var party : Array = TinyPlayer.getInstance().fullParty.party;			var oldParty_A : Array = party.slice(1, 4);			var oldParty_B : Array = party.slice(4);			var newParty : Array = [];			newParty = newParty.concat(oldParty_A, party[0], oldParty_B);			TinyEventSequence.outParty = newParty;						// Throw everybody out below the map and have them walk up								for each (var char : TinyStatsEntity in newParty) 			{				if (char.name.toUpperCase() != 'HYBRID' &&					char.name.toUpperCase() != 'EVAN?' &&					char.name.toUpperCase() != 'EVAN' &&					char.name.toUpperCase() != 'FISH') 				{					// Only add non-players, but count the player anyway to skip their position					if (char.name.toUpperCase() != TinyPlayer.getInstance().playerName.toUpperCase()) 					{						// Remove sprite decorations						char.graphics.selected = false;						TinyFriendSprite(char.graphics).active = false;												// Add sprite						var position : Point = new Point(40 + (count * (spacing + TinyMath.randomInt(0, 5))), 270);						TinyFieldMap.getInstance().addNPCSpriteAt(TinyFriendSprite(char.graphics), position.x, position.y, 'UP');												// Keep max delay time						var delay : int = TinyMath.randomInt(count, 24 + count);						if (delay > maxDelay) 							maxDelay = delay;						// Walk and stop						TweenLite.delayedCall(delay, TinyFriendSprite(char.graphics).walkBack, null, true);						TweenLite.delayedCall(delay + 34 + TinyMath.randomInt(0, 7), TinyFriendSprite(char.graphics).idleWalk, null, true);					}					count ++;				}			}						// Next!			TweenLite.delayedCall(maxDelay, this.doNextCommand, null, true);		}				private function doSuckToCenter() : void		{			TinyLogManager.log('doSuckToCenter', this);						// Throw everybody out below the map and have them walk up								for each (var char : TinyStatsEntity in TinyPlayer.getInstance().fullParty.party) 			{				if (char.name.toUpperCase() != 'HYBRID' &&					char.name.toUpperCase() != 'EVAN?'  &&					char.name.toUpperCase() != 'EVAN'   &&					char.name.toUpperCase() != 'FISH')				{					TweenLite.delayedCall(TinyMath.randomInt(0, 8), TinyFriendSprite(char.graphics).suckToCenter, null, true);				}			}						// Don't forget Jeremy!			TweenLite.delayedCall(TinyMath.randomInt(0, 20), TinyFieldMap.getNPCSpriteByName('JEREMY').suckToCenter, null, true);						// Next!			this.doNextCommand();		}				private function doShowHybrid() : void		{			TinyLogManager.log('doShowHybrid', this);						// Make hybrid			this.theHybrid = TinyFriendSprite(TinyPlayer.getInstance().fullParty.getCharByName('HYBRID').graphics);			this.theHybrid.x = 160;			this.theHybrid.y = 140;			this.theHybrid.facing = 'LEFT';			this.theHybrid.idleWalk();			this.theHybrid.idleBattle();						// Make mask			this.theMask = new Sprite;			this.theMask.addChild(new Bitmap(new MaskGradient));			this.theMask.y = this.theHybrid.y + 36;						// Set mask			this.theMask.cacheAsBitmap = 			this.theHybrid.cacheAsBitmap = true; 			this.theHybrid.mask = this.theMask;						this.addChild(this.theHybrid);			this.addChild(this.theMask);						// Animate			TweenLite.to(this.theHybrid, 0, { colorTransform:{tint:0xFFFFFF, tintAmount:1} });			TweenLite.to(this.theHybrid, 60, { delay:20, colorTransform:{tint:0xFFFFFF, tintAmount:0}, ease:SteppedEase.create(5), useFrames:true });			TweenLite.to(this.theMask, 80, { y:this.theHybrid.y - 75, ease:SteppedEase.create(4), useFrames:true, onComplete:onHybridMaskComplete });						// Replace entire party with the hybrid			TinyPlayer.getInstance().party.party = [];			TinyPlayer.getInstance().party.addMember(TinyPlayer.getInstance().fullParty.getCharByName('HYBRID'));			TinyPlayer.getInstance().party.getCharByName('HYBRID').stats.levelTo(20);						// Next!			this.doNextCommand();		}				private function onHybridMaskComplete() : void		{			TinyLogManager.log('onHybridMaskComplete', this);						this.theHybrid.mask = null;			this.removeChild(this.theMask);			this.theMask = null;		}		private function doEnd() : void		{			TinyLogManager.log('DEPTH: ' + this.eventDepth + ' doEnd', this);			this.dispatchEvent(new Event(Event.COMPLETE));		}				private function doFinalEnd() : void		{			TinyLogManager.log('DEPTH: ' + this.eventDepth + ' doFinalEnd', this);			this.dispatchEvent(new TinySequenceEvent(TinySequenceEvent.SEQUENCE_END));		}	}}