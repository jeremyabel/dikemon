package com.tinyrpg.display {	import com.greensock.TweenLite;	import com.tinyrpg.core.ITinySprite;	import com.tinyrpg.core.TinyEnemySprite;	import com.tinyrpg.core.TinyFriendSprite;	import com.tinyrpg.core.TinyParty;	import com.tinyrpg.core.TinyStatsEntity;	import com.tinyrpg.events.TinyInputEvent;	import com.tinyrpg.managers.TinyInputManager;	import com.tinyrpg.utils.TinyLogManager;	import flash.display.Sprite;	import flash.geom.Point;	/**	 * @author jeremyabel	 */	public class TinyBattlePartyDisplay extends Sprite 	{		private var characterArray 	: Array = [];		private var graphicsArray	: Array = [];		private var selectedChar 	: Sprite;		private var isEnemy			: Boolean;		private var _turnCharacter	: Sprite;		private var _selectedChar	: Sprite;				// Friend patterns		private var friendPattern1 	: Point = new Point(-23, 23);		private var friendPattern2 	: Array = [ new Point(-12, 12), new Point(-38, 38) ];		private var friendPattern3	: Array = [ new Point(0, 0), new Point(-26, 23), new Point(-53, 55) ];		private var friendPattern4  : Array = [ new Point(0, 0), new Point(-14, 18), new Point(-28, 37), new Point(-53, 56) ];				// Enemy patterns		private var enemyPattern1 : Point = new Point(43, 33);		private var enemyPattern2 : Array = [ new Point(12, 12), new Point(58, 38) ];		//private var enemyPattern3 : Array;		//private var enemyPattern4 : Array;				public function TinyBattlePartyDisplay(party : TinyParty, isEnemy : Boolean = false)		{			this.characterArray = party.party;			this.isEnemy = isEnemy;		}		public function show() : void		{			TinyLogManager.log('show', this);						// Set up graphics array			var i : uint = 0;			for each (var char : TinyStatsEntity in this.characterArray) 			{				var charGraphics : ITinySprite = ITinySprite(char.graphics);								// Friend placement				if (!this.isEnemy) {					// Set idle animation					TinyFriendSprite(charGraphics).idleDirection('LEFT');					TinyFriendSprite(charGraphics).idleBattle();										switch (this.characterArray.length)					{						case 1:							charGraphics.x = this.friendPattern1.x;							charGraphics.y = this.friendPattern1.y;							break;						case 2:							charGraphics.x = Point(this.friendPattern2[i]).x;							charGraphics.y = Point(this.friendPattern2[i]).y;							break;						case 3:							charGraphics.x = Point(this.friendPattern3[i]).x;							charGraphics.y = Point(this.friendPattern3[i]).y;							break;						case 4:							charGraphics.x = Point(this.friendPattern4[i]).x;							charGraphics.y = Point(this.friendPattern4[i]).y;							break;					}				// Enemy placement				} else {					// Ensure our animated enemies start off right					if (Sprite(charGraphics).hasOwnProperty('spriteIdleFront')) {						TinyFriendSprite(charGraphics).idleDirection('RIGHT');						TinyFriendSprite(charGraphics).idleBattle();						TinyFriendSprite(charGraphics).swapArrow();					} else {						// Reset						if (TinyEnemySprite(charGraphics).spriteHolder)						{							TweenLite.to(TinyEnemySprite(charGraphics).spriteHolder, 0, { colorTransform:{tint:0xFF0000, tintAmount:0} });							TinyEnemySprite(charGraphics).spriteHolder.alpha = 1;							Sprite(charGraphics).alpha = 1;						}												char.stats.HP = char.stats.MHP;					}					trace('wat 5');										switch (this.characterArray.length)					{					 	case 1:					 		charGraphics.x = this.enemyPattern1.x;					 		charGraphics.y = this.enemyPattern1.y;							break;					 	case 2:					 		charGraphics.x = Point(this.enemyPattern2[i]).x;					 		charGraphics.y = Point(this.enemyPattern2[i]).y;					 		break;					 	case 3:					 		break;					 	default:					 	case 4:					 		break;					 }				}				this.addChild(Sprite(charGraphics));				this.graphicsArray.push(charGraphics);				i++;			}		}				public function set turnCharacter(target : TinyStatsEntity) : void		{			var char : Sprite;						// Remove arrow if there's no target			if (!target) {				TinyLogManager.log('set turnCharacter: none', this);				for each (char in this.graphicsArray) 					char['active'] = false;				return;			}			TinyLogManager.log('set turnCharacter: ' + target.name, this);						var turnCharacter : Sprite = this.findCharByID(target.idNumber);			if (!turnCharacter) 			{				// Yeah, this is bad.				TinyLogManager.log('turnCharacter: COULD NOT FIND CHARACTER!', this);				return;			} 			else 			{				// Disable tiny arrow on all				for each (char in this.graphicsArray) 					char['active'] = false;								// Enable tiny arrow on one				turnCharacter['active'] = true;				this._turnCharacter = turnCharacter;			}		}				public function set selectCharacter(target : TinyStatsEntity) : void		{			var char : Sprite;						// Remove arrow if there's no target			if (!target) {				TinyLogManager.log('set selectCharacter: none', this);				for each (char in this.graphicsArray) 					char['selected'] = false;				return;			}						TinyLogManager.log('set selectCharacter: ' + target.name, this);			var turnCharacter : Sprite = this.findCharByID(target.idNumber);			if (!turnCharacter) 			{				// Yeah, this is bad.				TinyLogManager.log('selectCharacter: COULD NOT FIND CHARACTER!', this);				return;			} 			else 			{				// Disable tiny arrow on all				for each (char in this.graphicsArray) 					char['selected'] = false;								// Enable tiny arrow on one				turnCharacter['selected'] = true;				this._selectedChar = turnCharacter;			}					}		public function killCharacter(target : TinyStatsEntity, boss : Boolean = false) : void		{			TinyLogManager.log('killCharacter: ' + target.name, this);						var targetSprite : Sprite = this.findCharByID(target.idNumber);						if (boss) {				if (targetSprite is TinyEnemySprite) 					TinyEnemySprite(targetSprite).dieBig();				else 					TinyFriendSprite(targetSprite).dieBig();			} else {				if (targetSprite is TinyEnemySprite) 					TinyEnemySprite(targetSprite).die();				else 					TinyFriendSprite(targetSprite).die();			}		}				public function findCharByID(targetID : int) : Sprite		{			// Find function			var findFunction : Function = function(item : *, index : int, array : Array) : Boolean				{ index; array; return (item['idNumber'] == targetID); };						// Search for character			return this.graphicsArray.filter(findFunction)[0];		}						protected function onControlAdded(e : TinyInputEvent) : void		{			TinyLogManager.log('onControlAdded', this);						// Select first item			this.selectedChar = this.graphicsArray[0];			TinySelectableItem(this.graphicsArray[0]).selected = true;						// Add events			TinyInputManager.getInstance().addEventListener(TinyInputEvent.ARROW_UP, onArrowUp);			TinyInputManager.getInstance().addEventListener(TinyInputEvent.ARROW_DOWN, onArrowDown);			TinyInputManager.getInstance().addEventListener(TinyInputEvent.ACCEPT, onAccept);			TinyInputManager.getInstance().addEventListener(TinyInputEvent.CANCEL, onCancel);			this.addEventListener(TinyInputEvent.CONTROL_REMOVED, onControlRemoved);			this.removeEventListener(TinyInputEvent.CONTROL_ADDED, onControlAdded);		}		protected function onControlRemoved(e : TinyInputEvent) : void		{			TinyLogManager.log('onControlRemoved', this);						// Remove selection			this.selectedChar['selected'] = false;						// Remove events			TinyInputManager.getInstance().removeEventListener(TinyInputEvent.ARROW_UP, onArrowUp);			TinyInputManager.getInstance().removeEventListener(TinyInputEvent.ARROW_DOWN, onArrowDown);			TinyInputManager.getInstance().removeEventListener(TinyInputEvent.ACCEPT, onAccept);			TinyInputManager.getInstance().removeEventListener(TinyInputEvent.CANCEL, onCancel);			this.removeEventListener(TinyInputEvent.CONTROL_REMOVED, onControlRemoved);			this.addEventListener(TinyInputEvent.CONTROL_ADDED, onControlAdded);		}		protected function onArrowUp(event : TinyInputEvent) : void 		{			this.selectedChar['selected'] = false;			var oldSelectID : int = this.selectedChar['idNumber'];						if (oldSelectID == 0) {				this.selectedChar = this.graphicsArray[this.graphicsArray.length - 1];			} else {									this.selectedChar = this.graphicsArray[(oldSelectID - 1) % this.graphicsArray.length];			}						this.selectedChar['selected'] = true;						TinyLogManager.log('onKeyDown: UP   Selected Item: ' + this.selectedChar.name, this);		}				protected function onArrowDown(event : TinyInputEvent) : void 		{			this.selectedChar['selected'] = false;			var oldSelectID : int = this.selectedChar['idNumber'];			this.selectedChar = this.graphicsArray[(oldSelectID + 1) % this.graphicsArray.length];			this.selectedChar['selected'] = true;			TinyLogManager.log('onKeyDown: DOWN   Selected Item: ' + this.selectedChar.name, this);		}				protected function onAccept(event : TinyInputEvent) : void 		{			TinyLogManager.log('onAccept', this);		}		protected function onCancel(event : TinyInputEvent) : void 		{			TinyLogManager.log('onCancel', this);					}	}}